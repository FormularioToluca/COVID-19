import { __decorate, __metadata, __param } from 'tslib';
import { Directive, TemplateRef, ViewChild, ElementRef, ContentChild, HostListener, Component, Optional, Input, NgModule, Renderer2, EventEmitter, Output, ComponentFactoryResolver, ViewContainerRef, Injectable, InjectionToken, ContentChildren, QueryList, forwardRef, ChangeDetectionStrategy, Self, Inject, ChangeDetectorRef, Injector, ComponentRef, ApplicationRef, Attribute, Pipe } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavigationEnd, Router, ActivatedRoute, RouterModule, RouterOutlet, ChildrenOutletContexts, NavigationStart, RouterLinkWithHref } from '@angular/router';
import { filter, debounceTime, switchMap, tap, catchError, takeUntil, skip } from 'rxjs/operators';
import { BehaviorSubject, Subject, NEVER, of } from 'rxjs';
import { NG_VALUE_ACCESSOR, NgControl, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { HttpErrorResponse } from '@angular/common/http';
import * as flatpickrImport from 'flatpickr';

let MainNavItemsDirective = class MainNavItemsDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
MainNavItemsDirective = __decorate([
    Directive({
        selector: '[rbMainNavItems]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], MainNavItemsDirective);
let SubNavItemsDirective = class SubNavItemsDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
SubNavItemsDirective = __decorate([
    Directive({
        selector: '[rbSubNavItems]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], SubNavItemsDirective);
let MetaNavItemsDirective = class MetaNavItemsDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
MetaNavItemsDirective = __decorate([
    Directive({
        selector: '[rbMetaNavItems]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], MetaNavItemsDirective);
let ActionNavItemsDirective = class ActionNavItemsDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ActionNavItemsDirective = __decorate([
    Directive({
        selector: '[rbActionNavItems]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], ActionNavItemsDirective);

let SubBrandHeaderDirective = class SubBrandHeaderDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
SubBrandHeaderDirective = __decorate([
    Directive({
        selector: '[rbSubBrandHeader]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], SubBrandHeaderDirective);
let LogoHeaderDirective = class LogoHeaderDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
LogoHeaderDirective = __decorate([
    Directive({
        selector: '[rbLogoHeader]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], LogoHeaderDirective);

let FullHeaderComponent = class FullHeaderComponent {
    constructor(router) {
        this.router = router;
        this.open = false;
        this.opened = false;
        this.fullHeight = null;
    }
    ngOnInit() {
        if (this.router) {
            this.router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe(event => {
                this.open = false;
            });
        }
    }
    toggle() {
        this.open = !this.open;
        if (this.open) {
            this.opened = true;
        }
    }
    onScroll() {
        const header = this.headerElement.nativeElement;
        const placeholder = this.headerPlaceholderElement.nativeElement;
        const height = header.offsetHeight;
        const isSticky = header.classList.contains('sticky');
        if (!isSticky) {
            this.fullHeight = height;
        }
        if (window.pageYOffset > this.fullHeight && !isSticky) {
            header.classList.add('sticky');
            placeholder.classList.add('sticky');
            placeholder.style.height = this.fullHeight + 'px';
        }
        else if (window.pageYOffset <= this.fullHeight && isSticky) {
            header.classList.remove('sticky');
            placeholder.classList.remove('sticky');
        }
    }
};
__decorate([
    ViewChild('header', { static: true }),
    __metadata("design:type", ElementRef)
], FullHeaderComponent.prototype, "headerElement", void 0);
__decorate([
    ViewChild('placeholder', { static: true }),
    __metadata("design:type", ElementRef)
], FullHeaderComponent.prototype, "headerPlaceholderElement", void 0);
__decorate([
    ContentChild(MainNavItemsDirective, { static: false }),
    __metadata("design:type", MainNavItemsDirective)
], FullHeaderComponent.prototype, "mainNavItems", void 0);
__decorate([
    ContentChild(SubNavItemsDirective, { static: false }),
    __metadata("design:type", SubNavItemsDirective)
], FullHeaderComponent.prototype, "subNavItems", void 0);
__decorate([
    ContentChild(MetaNavItemsDirective, { static: false }),
    __metadata("design:type", MetaNavItemsDirective)
], FullHeaderComponent.prototype, "metaNavItems", void 0);
__decorate([
    ContentChild(ActionNavItemsDirective, { static: false }),
    __metadata("design:type", ActionNavItemsDirective)
], FullHeaderComponent.prototype, "actionNavItems", void 0);
__decorate([
    ContentChild(SubBrandHeaderDirective, { static: false }),
    __metadata("design:type", SubBrandHeaderDirective)
], FullHeaderComponent.prototype, "subBrand", void 0);
__decorate([
    ContentChild(LogoHeaderDirective, { static: false }),
    __metadata("design:type", LogoHeaderDirective)
], FullHeaderComponent.prototype, "customLogo", void 0);
__decorate([
    HostListener('window:scroll'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FullHeaderComponent.prototype, "onScroll", null);
FullHeaderComponent = __decorate([
    Component({
        selector: 'rb-full-header',
        template: "<div class=\"header-placeholder\" #placeholder></div>\r\n<header class=\"header\" #header>\r\n  <div class=\"supergraphic bar\"></div>\r\n  <div class=\"header-content limit\">\r\n    <div class=\"logo\" *ngIf=\"customLogo\">\r\n      <ng-container *ngTemplateOutlet=\"customLogo.templateRef\"></ng-container>\r\n    </div>\r\n    <div class=\"logo\" *ngIf=\"!customLogo\">\r\n      <a href=\"https://www.bosch.com/\" target=\"_blank\">\r\n        <img src=\"assets/img/Bosch_EN_LV_RGB.png\" alt=\"Bosch - Invented for life\">\r\n      </a>\r\n    </div>\r\n    <div class=\"sub-brand\" *ngIf=\"subBrand\">\r\n      <div class=\"sub-brand-content\">\r\n        <ng-container *ngTemplateOutlet=\"subBrand.templateRef\"></ng-container>\r\n      </div>\r\n    </div>\r\n    <div class=\"small-nav\">\r\n      <button class=\"toggler\" [class.open]=\"open\" (click)=\"toggle()\">\r\n        <span class=\"bar\"></span>\r\n        <span class=\"bar\"></span>\r\n        <span class=\"bar\"></span>\r\n      </button>\r\n    </div>\r\n    <div class=\"main-nav\" [class.open]=\"open\" [class.opened]=\"opened\" *ngIf=\"mainNavItems\">\r\n      <rb-navigation type=\"main\" [itemsTemplate]=\"mainNavItems\"></rb-navigation>\r\n    </div>\r\n    <div class=\"action-nav\">\r\n      <rb-navigation type=\"action\" [itemsTemplate]=\"actionNavItems\"></rb-navigation>\r\n    </div>\r\n    <div class=\"sub-nav\" [class.open]=\"open\" [class.opened]=\"opened\" *ngIf=\"subNavItems\">\r\n      <rb-navigation type=\"sub\" [itemsTemplate]=\"subNavItems\"></rb-navigation>\r\n    </div>\r\n    <div class=\"meta-nav\" [class.open]=\"open\" [class.opened]=\"opened\" *ngIf=\"metaNavItems\">\r\n      <rb-navigation type=\"meta\" [itemsTemplate]=\"metaNavItems\"></rb-navigation>\r\n    </div>\r\n  </div>\r\n\r\n</header>\r\n"
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [Router])
], FullHeaderComponent);

let NavigationComponent = class NavigationComponent {
    constructor() {
        this.type = 'main'; // type of navigation
    }
    ngOnInit() {
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], NavigationComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigationComponent.prototype, "itemsTemplate", void 0);
NavigationComponent = __decorate([
    Component({
        selector: 'rb-navigation',
        template: "<nav [class]=\"'nav-'+type\">\n  <ng-container *ngTemplateOutlet=\"itemsTemplate?.templateRef\"></ng-container>\n  <ng-content></ng-content>\n</nav>\n"
    }),
    __metadata("design:paramtypes", [])
], NavigationComponent);

let NavigationModule = class NavigationModule {
};
NavigationModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            NavigationComponent
        ],
        exports: [
            NavigationComponent
        ]
    })
], NavigationModule);

let FullHeaderModule = class FullHeaderModule {
};
FullHeaderModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            NavigationModule,
        ],
        declarations: [
            FullHeaderComponent,
            MainNavItemsDirective,
            SubNavItemsDirective,
            MetaNavItemsDirective,
            SubBrandHeaderDirective,
            LogoHeaderDirective,
            ActionNavItemsDirective
        ],
        exports: [
            FullHeaderComponent,
            MainNavItemsDirective,
            SubNavItemsDirective,
            MetaNavItemsDirective,
            SubBrandHeaderDirective,
            LogoHeaderDirective,
            ActionNavItemsDirective
        ]
    })
], FullHeaderModule);

/**
 * @Deprecated use the icon font with rb-ic css class
 */
let IconComponent = class IconComponent {
    constructor() {
        this.basePath = 'assets/img/icons.svg';
    }
    ngOnInit() {
        // if it is MSIE
        if (!!document['documentMode'] && window['XMLHttpRequest']) {
            if (!document.getElementById('rb-icons')) {
                const iconsEl = document.createElement('div');
                iconsEl.id = 'rb-icons';
                iconsEl.style.display = 'none';
                document.body.appendChild(iconsEl);
                const http = new window['XMLHttpRequest']();
                http.onreadystatechange = () => {
                    if (http.readyState == 4 && http.status == 200) {
                        iconsEl.innerHTML = http.responseText;
                    }
                };
                http.open('GET', this.basePath, true);
                http.send();
            }
            this.basePath = '';
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], IconComponent.prototype, "name", void 0);
IconComponent = __decorate([
    Component({
        selector: 'rb-icon',
        template: "<!--<img [src]=\"'assets/images/icons/'+name+'.svg'\" [alt]=\"name\">-->\n\n<svg viewBox=\"0 0 100 100\" class=\"icon\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <use [attr.xlink:href]=\"basePath+'#'+name\"></use>\n</svg>\n",
        styles: ["svg{height:1em;width:1em}"]
    }),
    __metadata("design:paramtypes", [])
], IconComponent);

let IconModule = class IconModule {
};
IconModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [IconComponent],
        exports: [IconComponent]
    })
], IconModule);

let FooterNavComponent = class FooterNavComponent {
    constructor(renderer) {
        this.renderer = renderer;
    }
    ngOnInit() {
        this.checkSticky();
    }
    ngDoCheck() {
        this.checkSticky();
    }
    onResize() {
        this.checkSticky();
    }
    checkSticky() {
        const footer = this.footerEl.nativeElement;
        const footerHeight = footer.offsetHeight;
        const windowHeight = window.innerHeight;
        const bottomBorder = footer.offsetTop + footer.offsetHeight;
        const realContentHeight = document.body.firstElementChild.offsetHeight;
        const sticky = footer.classList.contains('sticky');
        if (!sticky && bottomBorder < windowHeight) {
            this.renderer.addClass(footer, 'sticky');
            this.renderer.setStyle(this.placeholderEl.nativeElement, 'height', footerHeight + 'px');
        }
        else if (sticky && realContentHeight >= windowHeight) {
            this.renderer.removeClass(footer, 'sticky');
        }
    }
};
__decorate([
    ViewChild('footer', { static: true }),
    __metadata("design:type", ElementRef)
], FooterNavComponent.prototype, "footerEl", void 0);
__decorate([
    ViewChild('placeholder', { static: true }),
    __metadata("design:type", ElementRef)
], FooterNavComponent.prototype, "placeholderEl", void 0);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FooterNavComponent.prototype, "onResize", null);
FooterNavComponent = __decorate([
    Component({
        selector: 'rb-footer-nav',
        template: "<footer #footer>\n  <ng-content></ng-content>\n  <div class=\"supergraphic bar\"></div>\n</footer>\n<div class=\"footer-placeholder\" #placeholder></div>\n"
    }),
    __metadata("design:paramtypes", [Renderer2])
], FooterNavComponent);

let FooterNavModule = class FooterNavModule {
};
FooterNavModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [FooterNavComponent],
        exports: [FooterNavComponent]
    })
], FooterNavModule);

function getAbsolutePosition(el) {
    const pos = { x: 0, y: 0 };
    let checkEl = el;
    while (checkEl) {
        pos.x += checkEl.offsetLeft;
        pos.y += checkEl.offsetTop;
        checkEl = checkEl.offsetParent;
    }
    return pos;
}

let PopoverComponent = class PopoverComponent {
    constructor() {
        this.primaryPos = 'bottom';
        this.close = new EventEmitter();
        this.mouseIn = false;
        this.initialized = false;
        this.context = {
            close: this.doClose.bind(this)
        };
    }
    onMouseEnter() {
        this.mouseIn = true;
    }
    onMouseLeave() {
        this.mouseIn = false;
    }
    onAnyClick() {
        if (!this.mouseIn && this.initialized) {
            this.close.next('click');
        }
    }
    onResize() {
        this.positionToAnchor();
    }
    ngOnInit() {
        setTimeout(() => {
            this.initialized = true;
            this.positionToAnchor();
        });
        this.positionToAnchor();
    }
    ngAfterViewInit() {
        this.positionToAnchor();
    }
    doClose() {
        this.close.next();
    }
    positionToAnchor() {
        if (!this.anchor || !this.popoverElementRef) {
            return;
        }
        const a = this.anchor instanceof HTMLElement ? this.anchor : this.anchor.nativeElement;
        const pop = this.popoverElementRef.nativeElement;
        const arrow = this.arrowElementRef.nativeElement;
        const anchorPos = getAbsolutePosition(a);
        if (this.primaryPos === 'top' || this.primaryPos === 'bottom') {
            anchorPos.x += a.offsetWidth / 2;
            let isBottom = this.primaryPos === 'bottom';
            const pos = {
                x: anchorPos.x - pop.offsetWidth / 2,
                y: 0
            };
            if (!isBottom) {
                pos.y = anchorPos.y - pop.offsetHeight - arrow.offsetHeight / 2;
                if (pos.y < 0) {
                    isBottom = true;
                }
            }
            if (isBottom) {
                pos.y = anchorPos.y + a.offsetHeight + arrow.offsetHeight / 2;
                arrow.classList.remove('bottom');
            }
            else {
                arrow.classList.add('bottom');
            }
            if (pos.x + pop.offsetWidth > window.innerWidth) {
                pos.x = window.innerWidth - pop.offsetWidth;
            }
            if (pos.x < 0) {
                pos.x = 0;
            }
            const popParentPos = getAbsolutePosition(pop.offsetParent);
            pos.y -= popParentPos.y;
            pos.x -= popParentPos.x;
            pop.style.top = pos.y + 'px';
            pop.style.left = pos.x + 'px';
            const arrowX = anchorPos.x - (pos.x + popParentPos.x) - arrow.offsetWidth / 2;
            arrow.style.left = arrowX + 'px';
        }
        if (this.primaryPos === 'left' || this.primaryPos === 'right') {
            anchorPos.y += a.offsetHeight / 2;
            let isRight = this.primaryPos === 'right';
            const pos = {
                x: 0,
                y: anchorPos.y - pop.offsetHeight / 2,
            };
            if (!isRight) {
                pos.x = anchorPos.x - pop.offsetWidth - arrow.offsetWidth / 2;
                if (pos.x < 0) {
                    isRight = true;
                }
            }
            if (isRight) {
                pos.x = anchorPos.x + a.offsetWidth + arrow.offsetWidth / 2;
                arrow.classList.remove('right');
                arrow.classList.add('left');
            }
            else {
                arrow.classList.add('right');
                arrow.classList.remove('left');
            }
            if (pos.y < 0) {
                pos.y = 0;
            }
            const popParentPos = getAbsolutePosition(pop.offsetParent);
            pos.y -= popParentPos.y;
            pos.x -= popParentPos.x;
            pop.style.top = pos.y + 'px';
            pop.style.left = pos.x + 'px';
            const arrowY = anchorPos.y - (pos.y + popParentPos.y) - arrow.offsetHeight / 2;
            arrow.style.top = arrowY + 'px';
        }
    }
    isTemplate() {
        return this.content instanceof TemplateRef;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopoverComponent.prototype, "anchor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopoverComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PopoverComponent.prototype, "primaryPos", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], PopoverComponent.prototype, "close", void 0);
__decorate([
    ViewChild('popover', { static: true }),
    __metadata("design:type", ElementRef)
], PopoverComponent.prototype, "popoverElementRef", void 0);
__decorate([
    ViewChild('arrow', { static: true }),
    __metadata("design:type", ElementRef)
], PopoverComponent.prototype, "arrowElementRef", void 0);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PopoverComponent.prototype, "onMouseEnter", null);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PopoverComponent.prototype, "onMouseLeave", null);
__decorate([
    HostListener('window:click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PopoverComponent.prototype, "onAnyClick", null);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PopoverComponent.prototype, "onResize", null);
PopoverComponent = __decorate([
    Component({
        selector: 'rb-popover',
        template: "<div class=\"rb-popover\" #popover>\r\n  <div class=\"rb-popover-arrow\" #arrow></div>\r\n  <div class=\"rb-popover-content\" *ngIf=\"isTemplate()\">\r\n    <ng-container *ngTemplateOutlet=\"content; context: context\"></ng-container>\r\n  </div>\r\n  <div class=\"rb-popover-content-text\" *ngIf=\"!isTemplate()\">\r\n    {{content}}\r\n  </div>\r\n</div>\r\n"
    }),
    __metadata("design:paramtypes", [])
], PopoverComponent);

let PopoverDirective = class PopoverDirective {
    constructor(factoryResolver, viewContainerRef) {
        this.factoryResolver = factoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.position = 'bottom';
        this.componentRef = null;
        this.closeSub = null;
    }
    ngOnDestroy() {
        this.closePopOver();
    }
    set template(tpl) {
        this.content = tpl;
    }
    onClick(e) {
        e.preventDefault();
        this.openPopOver();
    }
    openPopOver() {
        if (this.componentRef) {
            this.closePopOver();
            return;
        }
        const componentFactory = this.factoryResolver.resolveComponentFactory(PopoverComponent);
        this.componentRef = this.viewContainerRef.createComponent(componentFactory);
        this.componentRef.instance.anchor = this.anchor || this.viewContainerRef.element;
        this.componentRef.instance.content = this.content;
        this.componentRef.instance.primaryPos = this.position;
        this.closeSub = this.componentRef.instance.close.subscribe(() => {
            this.closePopOver();
        });
        this.viewContainerRef.element.nativeElement.classList.add('open');
    }
    closePopOver() {
        if (this.componentRef) {
            if (this.closeSub) {
                this.closeSub.unsubscribe();
            }
            this.viewContainerRef.element.nativeElement.classList.remove('open');
            const viewIndex = this.viewContainerRef.indexOf(this.componentRef.hostView);
            if (viewIndex !== -1) {
                this.viewContainerRef.remove(viewIndex);
            }
            this.componentRef = null;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], PopoverDirective.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopoverDirective.prototype, "anchor", void 0);
__decorate([
    Input('rbPopover'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], PopoverDirective.prototype, "template", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], PopoverDirective.prototype, "onClick", null);
PopoverDirective = __decorate([
    Directive({
        selector: '[rbPopover]',
        exportAs: 'rbPopover'
    }),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        ViewContainerRef])
], PopoverDirective);

let TooltipDirective = class TooltipDirective {
    constructor(factoryResolver, viewContainerRef) {
        this.factoryResolver = factoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.position = 'top';
        /**
         * Disables that the tooltip stays open when clicked.
         * Instead the tooltip is closed.
         */
        this.noFix = false;
        this.componentRef = null;
        this.closeSub = null;
        this.fixed = false;
    }
    ngOnDestroy() {
        this.closeTooltip();
    }
    set template(tpl) {
        this.content = tpl;
    }
    onClick(e) {
        if (this.noFix === false) {
            e.preventDefault();
            e.stopPropagation();
            this.fixed = true;
            this.openTooltip();
        }
    }
    onEnter(e) {
        e.preventDefault();
        this.openTooltip();
    }
    onLeave(e) {
        if (!this.fixed) {
            e.preventDefault();
            this.closeTooltip();
        }
    }
    openTooltip() {
        if (this.componentRef) {
            this.updateComponentState();
            return;
        }
        const componentFactory = this.factoryResolver.resolveComponentFactory(PopoverComponent);
        this.componentRef = this.viewContainerRef.createComponent(componentFactory);
        const instance = this.componentRef.instance;
        instance.anchor = this.anchor || this.viewContainerRef.element;
        instance.content = this.content;
        instance.primaryPos = this.position;
        if (this.context) {
            Object.assign(instance.context, this.context);
        }
        instance.context.fixed = this.fixed;
        this.updateComponentState();
        this.closeSub = instance.close.subscribe(() => {
            this.closeTooltip();
        });
        this.viewContainerRef.element.nativeElement.classList.add('open');
    }
    updateComponentState() {
        const instance = this.componentRef.instance;
        instance.context.fixed = this.fixed;
        if (this.fixed) {
            this.viewContainerRef.element.nativeElement.classList.add('open-fixed');
            instance.popoverElementRef.nativeElement.classList.add('open-fixed');
        }
    }
    closeTooltip() {
        this.fixed = false;
        if (this.componentRef) {
            if (this.closeSub) {
                this.closeSub.unsubscribe();
            }
            this.viewContainerRef.element.nativeElement.classList.remove('open');
            this.viewContainerRef.element.nativeElement.classList.remove('open-fixed');
            const viewIndex = this.viewContainerRef.indexOf(this.componentRef.hostView);
            if (viewIndex !== -1) {
                this.viewContainerRef.remove(viewIndex);
            }
            this.componentRef = null;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipDirective.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipDirective.prototype, "noFix", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipDirective.prototype, "context", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipDirective.prototype, "anchor", void 0);
__decorate([
    Input('rbTooltip'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TooltipDirective.prototype, "template", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], TooltipDirective.prototype, "onClick", null);
__decorate([
    HostListener('mouseenter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], TooltipDirective.prototype, "onEnter", null);
__decorate([
    HostListener('mouseleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], TooltipDirective.prototype, "onLeave", null);
TooltipDirective = __decorate([
    Directive({
        selector: '[rbTooltip]',
        exportAs: 'rbPopover'
    }),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        ViewContainerRef])
], TooltipDirective);

let PopoverModule = class PopoverModule {
};
PopoverModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [PopoverComponent, PopoverDirective, TooltipDirective],
        exports: [PopoverComponent, PopoverDirective, TooltipDirective],
        entryComponents: [PopoverComponent]
    })
], PopoverModule);

let DropdownComponent = class DropdownComponent {
    constructor() {
        this.primaryPos = 'left';
        this.autoClose = true;
        this.hugContent = false;
        this.close = new EventEmitter();
        this.shown = false;
        this.updateContext({});
    }
    onAnyClick() {
        if (this.shown) {
            this.doClose('click');
        }
    }
    onClick(event) {
        event.stopPropagation();
        if (this.shown && this.autoClose) {
            this.doClose('click');
        }
    }
    onResize() {
        this.positionToAnchor();
    }
    ngOnInit() {
        setTimeout(() => {
            this.positionToAnchor();
        });
        this.positionToAnchor();
    }
    show() {
        setTimeout(() => {
            this.shown = true;
        });
        this.popoverElementRef.nativeElement.classList.add('open');
        this.positionToAnchor();
    }
    hide() {
        this.shown = false;
        this.popoverElementRef.nativeElement.classList.remove('open');
    }
    ngAfterViewChecked() {
        this.positionToAnchor();
    }
    positionToAnchor() {
        if (!this.anchor || !this.popoverElementRef) {
            return;
        }
        const a = this.anchor.nativeElement;
        const pop = this.popoverElementRef.nativeElement;
        const anchorPos = getAbsolutePosition(a);
        const viewTop = window.pageYOffset;
        const viewBottom = window.innerHeight + window.pageYOffset;
        let isBottom = true;
        if (!this.hugContent) {
            pop.style.minWidth = a.offsetWidth + 'px';
        }
        const pos = {
            x: anchorPos.x,
            y: 0
        };
        if (this.primaryPos === 'center') {
            pos.x += a.offsetWidth / 2 - pop.offsetWidth / 2;
        }
        if (this.primaryPos === 'right') {
            pos.x += a.offsetWidth - pop.offsetWidth;
        }
        pos.y = anchorPos.y + a.offsetHeight;
        if (pos.y + pop.offsetHeight > viewBottom) {
            isBottom = false;
        }
        if (!isBottom) {
            pos.y = anchorPos.y - pop.offsetHeight;
            if (pos.y < 0) {
                isBottom = true;
            }
        }
        if (isBottom) {
            pos.y = anchorPos.y + a.offsetHeight;
        }
        if (pos.x + pop.offsetWidth > window.innerWidth) {
            pos.x = window.innerWidth - pop.offsetWidth;
        }
        if (pos.x < 0) {
            pos.x = 0;
        }
        const popParentPos = getAbsolutePosition(pop.offsetParent);
        pos.y -= popParentPos.y;
        pos.x -= popParentPos.x;
        pop.style.top = pos.y + 'px';
        pop.style.left = pos.x + 'px';
    }
    doClose(reason) {
        this.close.next(reason);
    }
    updateContext(ctx) {
        this.context = Object.assign({}, ctx, { close: this.doClose.bind(this) });
    }
};
__decorate([
    Input(),
    __metadata("design:type", ElementRef)
], DropdownComponent.prototype, "anchor", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], DropdownComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DropdownComponent.prototype, "primaryPos", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "autoClose", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "hugContent", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "close", void 0);
__decorate([
    ViewChild('dropdown', { static: true }),
    __metadata("design:type", ElementRef)
], DropdownComponent.prototype, "popoverElementRef", void 0);
__decorate([
    HostListener('window:click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], DropdownComponent.prototype, "onAnyClick", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], DropdownComponent.prototype, "onClick", null);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], DropdownComponent.prototype, "onResize", null);
DropdownComponent = __decorate([
    Component({
        selector: 'rb-dropdown',
        template: "<div class=\"dropdown\" #dropdown>\n  <div class=\"dropdown-content\">\n    <ng-container *ngTemplateOutlet=\"content; context: context\"></ng-container>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], DropdownComponent);

let DropdownDirective = class DropdownDirective {
    constructor(factoryResolver, viewContainerRef) {
        this.factoryResolver = factoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.position = 'left';
        this.autoClose = true;
        this.renderOnInit = false;
        this.hugContent = false;
        this.openOnClick = true;
        this.componentRef = null;
        this.closeSub = null;
    }
    ngOnDestroy() {
        this.closeDropdown();
    }
    ngOnInit() {
        if (this.renderOnInit) {
            this.renderDropdown();
        }
    }
    set template(tpl) {
        this.tpl = tpl;
    }
    onClick(e) {
        if (!this.openOnClick) {
            return;
        }
        e.preventDefault();
        this.openDropdown();
    }
    set context(ctx) {
        this._context = ctx;
        if (this.componentRef) {
            this.componentRef.instance.updateContext(ctx);
        }
    }
    renderDropdown() {
        const componentFactory = this.factoryResolver.resolveComponentFactory(DropdownComponent);
        this.componentRef = this.viewContainerRef.createComponent(componentFactory);
        this.componentRef.instance.anchor = this.viewContainerRef.element;
        this.componentRef.instance.content = this.tpl;
        this.componentRef.instance.primaryPos = this.position;
        this.componentRef.instance.autoClose = this.autoClose;
        this.componentRef.instance.hugContent = this.hugContent;
        this.closeSub = this.componentRef.instance.close.subscribe(() => {
            this.closeDropdown();
        });
        if (this._context) {
            this.componentRef.instance.updateContext(this._context);
        }
    }
    openDropdown() {
        if (this.componentRef && !this.renderOnInit || this.renderOnInit && this.componentRef.instance.shown) {
            this.closeDropdown();
            return;
        }
        if (!this.renderOnInit) {
            this.renderDropdown();
        }
        this.componentRef.instance.show();
        this.viewContainerRef.element.nativeElement.classList.add('open');
    }
    closeDropdown() {
        if (this.componentRef) {
            this.componentRef.instance.hide();
            this.viewContainerRef.element.nativeElement.classList.remove('open');
            if (!this.renderOnInit) {
                if (this.closeSub) {
                    this.closeSub.unsubscribe();
                }
                const viewIndex = this.viewContainerRef.indexOf(this.componentRef.hostView);
                if (viewIndex !== -1) {
                    this.viewContainerRef.remove(viewIndex);
                }
                this.componentRef = null;
            }
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], DropdownDirective.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownDirective.prototype, "autoClose", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownDirective.prototype, "renderOnInit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownDirective.prototype, "hugContent", void 0);
__decorate([
    Input('rbDropdown'),
    __metadata("design:type", TemplateRef),
    __metadata("design:paramtypes", [TemplateRef])
], DropdownDirective.prototype, "template", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], DropdownDirective.prototype, "onClick", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DropdownDirective.prototype, "context", null);
DropdownDirective = __decorate([
    Directive({
        selector: '[rbDropdown]',
        exportAs: 'rbDropdown'
    }),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        ViewContainerRef])
], DropdownDirective);

let DropdownModule = class DropdownModule {
};
DropdownModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [DropdownComponent, DropdownDirective],
        entryComponents: [DropdownComponent],
        exports: [DropdownComponent, DropdownDirective]
    })
], DropdownModule);

let LanguageSelectorComponent = class LanguageSelectorComponent {
    constructor() {
        this.languageChange = new EventEmitter();
    }
    ngOnInit() {
    }
    selectLanguage(l) {
        this.language = l.id;
        this.languageChange.next(this.language);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], LanguageSelectorComponent.prototype, "languages", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LanguageSelectorComponent.prototype, "language", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], LanguageSelectorComponent.prototype, "languageChange", void 0);
LanguageSelectorComponent = __decorate([
    Component({
        selector: 'rb-language-selector',
        template: "<a href=\"javascript:\" [rbDropdown]=\"items\" [position]=\"'right'\" class=\"language-selector-link language rb-dropdown-toggle\">\n  {{language}}\n</a>\n<ng-template #items>\n  <ul class=\"link-list\">\n    <li *ngFor=\"let l of languages\">\n      <a href=\"javascript:\" (click)=\"selectLanguage(l)\" [class.active]=\"l.id === language\">\n        <span class=\"language\">{{l.id}}</span> | {{l.name}}\n      </a>\n    </li>\n  </ul>\n</ng-template>\n"
    }),
    __metadata("design:paramtypes", [])
], LanguageSelectorComponent);

let LanguageSelectorModule = class LanguageSelectorModule {
};
LanguageSelectorModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            DropdownModule,
            IconModule
        ],
        declarations: [LanguageSelectorComponent],
        exports: [LanguageSelectorComponent]
    })
], LanguageSelectorModule);

let LoadingSpinnerComponent = class LoadingSpinnerComponent {
    constructor() {
        this.size = 1;
    }
    ngOnInit() {
    }
    getHeight() {
        return this.calculate(60);
    }
    getWidth() {
        return this.calculate(60);
    }
    calculate(defaultVal) {
        if (this.size > 0 && this.size < 3) {
            return (defaultVal * this.size) + 'px';
        }
        else {
            return defaultVal + 'px';
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], LoadingSpinnerComponent.prototype, "size", void 0);
LoadingSpinnerComponent = __decorate([
    Component({
        selector: 'rb-loading-spinner',
        template: "<div class=\"rb-loader\" [ngStyle]=\"{width: getWidth(), height: getHeight()}\">\n  <div class=\"block1\"></div>\n  <div class=\"block2\"></div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], LoadingSpinnerComponent);

let LoadingSpinnerModule = class LoadingSpinnerModule {
};
LoadingSpinnerModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [LoadingSpinnerComponent],
        exports: [LoadingSpinnerComponent]
    })
], LoadingSpinnerModule);

/**
 * When you define routes, add data: {title: 'myTitle'} to define what is displayed in the breadcrumbs.
 * If the title property is not enough for you to determine what should be displayed, you can
 * just extend this service and provide your own. This is probably necessary when you use some i18n tooling.
 *
 * You need to provide this service to use the rb-breadcrumbs component.
 * e.g. BreadcrumbsModule.forRoot()
 */
let BreadcrumbsService = class BreadcrumbsService {
    constructor(router, activeRoute) {
        this.router = router;
        this.activeRoute = activeRoute;
        this.initAutomatedRouteRecognition();
    }
    initAutomatedRouteRecognition() {
        this.router.events.pipe(filter(event => event instanceof NavigationEnd))
            .subscribe(() => this.refresh());
        this.breadcrumbs = new BehaviorSubject(this.identifyRoute());
    }
    refresh() {
        this.breadcrumbs.next(this.identifyRoute());
    }
    identifyRoute() {
        const breadcrumbs = [];
        const path = ['/'];
        // Traverse route snapshots to get the breadcrumbs path
        for (let route = this.activeRoute.snapshot; route; route = route.firstChild) {
            if (route.outlet === 'primary') {
                path.push(...route.url.map(segment => segment.path));
            }
            const element = this.getBreadCrumbElement(route, path);
            if (element) {
                breadcrumbs.push(element);
            }
        }
        return breadcrumbs;
    }
    getBreadCrumbElement(route, path) {
        const element = {
            urlSegments: path.slice(0),
            title: '...'
        };
        if (route.outlet === 'primary' && route.data && route.data['title']) {
            element.title = typeof (route.data['title']) === 'function' ? route.data['title'](route) : route.data['title'];
            return element;
        }
        return null;
    }
};
BreadcrumbsService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Router,
        ActivatedRoute])
], BreadcrumbsService);

let BreadcrumbsComponent = class BreadcrumbsComponent {
    constructor(breadcrumbsService) {
        this.breadcrumbsService = breadcrumbsService;
        this.breadcrumbs = [];
        /**
         * Minimal amount of entries the breadcrumb must have to be displayed
         */
        this.minElements = 0;
        this.sub = null;
    }
    ngOnInit() {
        this.sub = this.breadcrumbsService.breadcrumbs.subscribe(list => {
            this.breadcrumbs = list;
        });
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], BreadcrumbsComponent.prototype, "minElements", void 0);
BreadcrumbsComponent = __decorate([
    Component({
        selector: 'rb-breadcrumbs',
        template: "<ng-container *ngIf=\"breadcrumbs.length >= minElements\">\n  <div class=\"limit breadcrumbs-container\">\n    <ul class=\"breadcrumbs\">\n      <li *ngFor=\"let data of breadcrumbs\">\n        <a [routerLink]=\"data.urlSegments\">{{data.title}}</a>\n      </li>\n    </ul>\n    <div class=\"breadcrumbs-right\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n  <hr class=\"no-margin\">\n</ng-container>\n"
    }),
    __metadata("design:paramtypes", [BreadcrumbsService])
], BreadcrumbsComponent);

var BreadcrumbsModule_1;
let BreadcrumbsModule = BreadcrumbsModule_1 = class BreadcrumbsModule {
    static forRoot() {
        return {
            ngModule: BreadcrumbsModule_1,
            providers: [
                BreadcrumbsService
            ]
        };
    }
};
BreadcrumbsModule = BreadcrumbsModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RouterModule
        ],
        declarations: [BreadcrumbsComponent],
        exports: [BreadcrumbsComponent]
    })
], BreadcrumbsModule);

let FormValidationMessageDirective = class FormValidationMessageDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.onTouched = false;
    }
    set rbFormValidationMessage(name) {
        this.name = name;
    }
    set rbFormValidationMessageOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FormValidationMessageDirective.prototype, "rbFormValidationMessage", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], FormValidationMessageDirective.prototype, "rbFormValidationMessageOnTouched", null);
FormValidationMessageDirective = __decorate([
    Directive({
        selector: '[rbFormValidationMessage]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], FormValidationMessageDirective);

function emptyFunction(arg) {
}

var FormInputComponent_1;
const CUSTOM_VALUE_CONVERTER = new InjectionToken('formInputCustomValueConverter');
let FormInputComponent = FormInputComponent_1 = class FormInputComponent {
    constructor(renderer, elementRef, valueConverter, cd) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.valueConverter = valueConverter;
        this.cd = cd;
        this.placeholder = '';
        this.label = null;
        this.type = 'text';
        this.id = 'input.' + Math.random();
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    ngAfterViewInit() {
        if (this.autofocus) {
            this.focus();
        }
        if (this.autocomplete !== undefined) {
            this.input.nativeElement.autocomplete = this.autocomplete;
        }
    }
    focus() {
        this.input.nativeElement.focus();
    }
    updateIcon(icon) {
        this.icon = icon;
        this.cd.detectChanges();
    }
    isReadonly() {
        return !!(this.readonly === '' || this.readonly);
    }
    updateValue(value) {
        this.checkValue(value);
        if (this.valueConverter) {
            this.onChange(this.valueConverter.valueToModel(value));
        }
        else {
            this.onChange(value);
        }
    }
    checkValue(value) {
        if (typeof (value) === 'string' && value.length > 0) {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        if (this.valueConverter) {
            value = this.valueConverter.modelToValue(value);
        }
        if (value === null || value === undefined) {
            value = '';
        }
        else {
            value = String(value);
        }
        this.checkValue(value);
        this.renderer.setProperty(this.input.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
    set maxlength(maxLength) {
        if (maxLength) {
            this.renderer.setAttribute(this.input.nativeElement, 'maxlength', maxLength);
        }
        else {
            this.renderer.removeAttribute(this.input.nativeElement, 'maxlength');
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormInputComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormInputComponent.prototype, "autocomplete", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormInputComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FormInputComponent.prototype, "autofocus", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormInputComponent.prototype, "messages", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormInputComponent.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FormInputComponent.prototype, "maxlength", null);
FormInputComponent = FormInputComponent_1 = __decorate([
    Component({
        selector: 'rb-form-input',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <input [type]=\"type\" [id]=\"id + 'input'\"\r\n         class=\"input\"\r\n         [class.with-icon]=\"icon\"\r\n         [placeholder]=\"placeholder\"\r\n         [autofocus]=\"autofocus\"\r\n         (blur)=\"onTouched()\"\r\n         (input)=\"updateValue($event.target.value)\"\r\n         [readonly]=\"isReadonly()\"\r\n         #input>\r\n  <span *ngIf=\"icon\" [ngClass]=\"'input-icon '+icon\"></span>\r\n  <label class=\"label\" [for]=\"id + 'input'\">\r\n    {{!isLabelTemplate() ? label : ''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormInputComponent_1), multi: true }],
        exportAs: 'rbFormInput',
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(2, Optional()), __param(2, Self()), __param(2, Inject(CUSTOM_VALUE_CONVERTER)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object, ChangeDetectorRef])
], FormInputComponent);

var FormCheckboxComponent_1;
let FormCheckboxComponent = FormCheckboxComponent_1 = class FormCheckboxComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.id = 'checkbox.' + Math.random();
        this.label = null;
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    updateValue(value) {
        this.onChange(value);
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        this.renderer.setProperty(this.input.nativeElement, 'checked', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FormCheckboxComponent.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FormCheckboxComponent.prototype, "noValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormCheckboxComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormCheckboxComponent.prototype, "label", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormCheckboxComponent.prototype, "input", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormCheckboxComponent.prototype, "messages", void 0);
FormCheckboxComponent = FormCheckboxComponent_1 = __decorate([
    Component({
        selector: 'rb-form-checkbox',
        template: "<div class=\"input-wrapper\" [class.disabled]=\"input.disabled\">\r\n  <label [for]=\"id + 'input'\">\r\n    <input type=\"checkbox\" class=\"checkbox-control\"\r\n           (blur)=\"onTouched()\" (change)=\"updateValue($event.target.checked)\"\r\n           [id]=\"id + 'input'\" #input>\r\n\r\n    <span class=\"checkbox-icon\">\r\n      <span class=\"check rb-ic rb-ic-checkmark\"></span>\r\n    </span>\r\n\r\n    <span class=\"label-text\">\r\n      {{!isLabelTemplate()?label:''}}\r\n      <ng-container *ngIf=\"isLabelTemplate()\">\r\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n      </ng-container>\r\n      <ng-content></ng-content>\r\n    </span>\r\n\r\n  </label>\r\n\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormCheckboxComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2])
], FormCheckboxComponent);

var FormSelectComponent_1;
let FormSelectComponent = FormSelectComponent_1 = class FormSelectComponent extends FormInputComponent {
    constructor(renderer, elementRef, valueConverter, cd) {
        super(renderer, elementRef, valueConverter, cd);
    }
};
FormSelectComponent = FormSelectComponent_1 = __decorate([
    Component({
        selector: 'rb-form-select',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <select class=\"input select\"\r\n          [id]=\"id + 'input'\"\r\n          (blur)=\"onTouched()\"\r\n          (change)=\"updateValue($event.target.value)\" #input>\r\n    <ng-content></ng-content>\r\n  </select>\r\n\r\n  <label [for]=\"id + 'input'\" class=\"label select-label\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"select-icon rb-ic rb-ic-down\"></span>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormSelectComponent_1), multi: true }]
    }),
    __param(2, Optional()), __param(2, Self()), __param(2, Inject(CUSTOM_VALUE_CONVERTER)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object, ChangeDetectorRef])
], FormSelectComponent);

var FormTextareaComponent_1;
let FormTextareaComponent = FormTextareaComponent_1 = class FormTextareaComponent extends FormInputComponent {
    constructor(renderer, elementRef, valueConverter, cd) {
        super(renderer, elementRef, valueConverter, cd);
    }
};
FormTextareaComponent = FormTextareaComponent_1 = __decorate([
    Component({
        selector: 'rb-form-textarea',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <textarea [id]=\"id + 'input'\" class=\"textarea\"\r\n            (blur)=\"onTouched()\" (input)=\"updateValue($event.target.value)\"\r\n            [readonly]=\"isReadonly()\"\r\n            [placeholder]=\"placeholder\"\r\n            #input></textarea>\r\n\r\n  <label [for]=\"id + 'input'\" class=\"label\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormTextareaComponent_1), multi: true }],
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(2, Optional()), __param(2, Self()), __param(2, Inject(CUSTOM_VALUE_CONVERTER)),
    __metadata("design:paramtypes", [Renderer2, ElementRef, Object, ChangeDetectorRef])
], FormTextareaComponent);

var FormMultiSelectComponent_1;
let MultiSelectOptionDirective = class MultiSelectOptionDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
MultiSelectOptionDirective = __decorate([
    Directive({
        selector: '[rbFormMultiSelectOption]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], MultiSelectOptionDirective);
let MultiSelectTitleDirective = class MultiSelectTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
MultiSelectTitleDirective = __decorate([
    Directive({
        selector: '[rbFormMultiSelectTitle]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], MultiSelectTitleDirective);
/**
 * Use this component to have multiple selections.
 * The value is a map of id -> state.
 * The items are an array of objects.
 * To identify the id of an object from the items array, provide the idField.
 */
let FormMultiSelectComponent = FormMultiSelectComponent_1 = class FormMultiSelectComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.label = null;
        this.id = 'multiSelect.' + Math.random();
        this.selectAllLabel = 'Select all';
        this.isMouseOver = false;
        /**
         * Property name of the property that contains the unique value of an item
         * Otherwise the JSON rep is used as value
         */
        this.idField = null;
        /**
         * What states should be offered per item
         * check: just checked(true) and unchecked(false)
         * optCheck: unchecked(null), include(true), exclude(false)
         */
        this.statesMode = 'check';
        this.numStates = 2;
        this._states = {
            'check': [false, true],
            'optCheck': [null, false, true]
        };
        this.maxItemsPreview = 3;
        this.allStates = null;
        this.countNotDefState = 0;
        this.firstNotDefStateItem = null;
        this._value = {};
        this.titleContext = {
            $implicit: null,
            count: 0,
            firstItem: null,
            states: null
        };
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
        this.getItemTrackId = (i, item) => {
            return this.getItemId(item.item);
        };
    }
    ngOnInit() {
        const states = this.getStates();
        this.numStates = states.length;
        this.allStates = states[0];
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    set items(items) {
        const states = this.getStates();
        this._items = items.map(item => {
            const id = this.getItemId(item);
            let state = states[0];
            if (this._value && this._value[id] !== undefined) {
                state = this._value[id];
            }
            return {
                item: item,
                state: state
            };
        });
        this.doOnChanges();
    }
    getItemId(item) {
        if (this.idField && item) {
            return item[this.idField];
        }
        else {
            return JSON.stringify(item);
        }
    }
    getStates() {
        return this._states[this.statesMode];
    }
    allStatesChange(state) {
        this.allStates = state;
        if (!this._items) {
            return;
        }
        this._items.forEach(item => {
            item.state = state;
        });
        this.notifyChanges();
    }
    updateStateOfItem(item, state) {
        item.state = state;
        if (this._items.some(d => d.state !== state)) {
            const states = this.getStates();
            this.allStates = states[0];
        }
        else {
            this.allStates = state;
        }
        this.notifyChanges();
    }
    getCurrentStatesObject() {
        const states = {};
        this._items.forEach(item => {
            const id = this.getItemId(item.item);
            states[id] = item.state;
        });
        return states;
    }
    doOnChanges() {
        this.firstNotDefStateItem = null;
        this.countNotDefState = 0;
        const states = this.getStates();
        if (!this._items) {
            return;
        }
        this._items.forEach(item => {
            if (item.state !== states[0]) {
                this.countNotDefState++;
                if (this.firstNotDefStateItem === null) {
                    this.firstNotDefStateItem = item;
                }
            }
        });
        this.titleContext = {
            $implicit: this._items,
            count: this.countNotDefState,
            firstItem: this.firstNotDefStateItem,
            states: this._value
        };
        if (this.countNotDefState === 0 && this.selectAllLabel === '') {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
    }
    notifyChanges() {
        this.doOnChanges();
        this.onChange(this.getCurrentStatesObject());
    }
    mouseover() {
        this.isMouseOver = true;
    }
    mouseleave() {
        this.isMouseOver = false;
    }
    writeValue(items) {
        this._value = items;
        if (items) {
            const states = this.getStates();
            this._items.forEach(item => {
                const id = this.getItemId(item.item);
                if (items[id] !== undefined) {
                    item.state = items[id];
                }
                else {
                    item.state = states[0];
                }
            });
        }
        this.doOnChanges();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormMultiSelectComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormMultiSelectComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormMultiSelectComponent.prototype, "selectAllLabel", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormMultiSelectComponent.prototype, "messages", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormMultiSelectComponent.prototype, "idField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormMultiSelectComponent.prototype, "statesMode", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormMultiSelectComponent.prototype, "maxItemsPreview", void 0);
__decorate([
    ContentChild(MultiSelectOptionDirective, { static: false }),
    __metadata("design:type", MultiSelectOptionDirective)
], FormMultiSelectComponent.prototype, "option", void 0);
__decorate([
    ContentChild(MultiSelectTitleDirective, { static: false }),
    __metadata("design:type", MultiSelectTitleDirective)
], FormMultiSelectComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], FormMultiSelectComponent.prototype, "items", null);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormMultiSelectComponent.prototype, "mouseover", null);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormMultiSelectComponent.prototype, "mouseleave", null);
FormMultiSelectComponent = FormMultiSelectComponent_1 = __decorate([
    Component({
        selector: 'rb-form-multi-select',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <button [rbDropdown]=\"dropdownContent\"\r\n          [id]=\"id\"\r\n          [autoClose]=\"false\"\r\n          [disabled]=\"disabled !== undefined\"\r\n          (blur)=\"onTouched()\"\r\n          class=\"rb-select-btn input\">\r\n\r\n    <ng-container *ngIf=\"title\">\r\n      <ng-container *ngTemplateOutlet=\"title.templateRef; context: titleContext\"></ng-container>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!title\">\r\n      <ng-container *ngIf=\"titleContext.count === 1\">\r\n        <ng-container *ngIf=\"option\">\r\n          <ng-container\r\n            *ngTemplateOutlet=\"option.templateRef; context: {$implicit: titleContext.firstItem.item}\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!option\">\r\n          {{titleContext.firstItem.item | json}}\r\n        </ng-container>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"titleContext.count > 1\">{{titleContext.count}} items selected</ng-container>\r\n    </ng-container>\r\n\r\n  </button>\r\n\r\n  <label [for]=\"id\" class=\"label rb-select-label\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"select-icon rb-ic rb-ic-down\"></span>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n\r\n\r\n<ng-template #dropdownContent>\r\n  <ng-container *ngIf=\"selectAllLabel\">\r\n    <rb-form-multi-checkbox [numStates]=\"numStates\"\r\n                            class=\"list-item-input\"\r\n                            [ngModel]=\"allStates\"\r\n                            (ngModelChange)=\"allStatesChange($event)\">\r\n      {{selectAllLabel}}\r\n    </rb-form-multi-checkbox>\r\n    <hr class=\"no-margin\">\r\n  </ng-container>\r\n\r\n  <div class=\"dropdown-limited\">\r\n    <ng-container *ngFor=\"let item of _items; trackBy: getItemTrackId\">\r\n      <rb-form-multi-checkbox [numStates]=\"numStates\"\r\n                              class=\"list-item-input\"\r\n                              [ngModel]=\"item.state\"\r\n                              (ngModelChange)=\"updateStateOfItem(item, $event)\">\r\n        <ng-container *ngIf=\"option\">\r\n          <ng-container *ngTemplateOutlet=\"option.templateRef; context: {$implicit: item.item}\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!option\">\r\n          {{item.item | json}}\r\n        </ng-container>\r\n      </rb-form-multi-checkbox>\r\n    </ng-container>\r\n  </div>\r\n\r\n</ng-template>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormMultiSelectComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], FormMultiSelectComponent);

var FormMultiCheckboxComponent_1;
let FormMultiCheckboxComponent = FormMultiCheckboxComponent_1 = class FormMultiCheckboxComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.id = 'multiCheckbox.' + Math.random();
        this.label = null;
        this.state = null;
        this.numStates = 2;
        this.stateLabels = ['stateNull', 'stateTrue', 'stateFalse'];
        this.statesValues = [null, true, false];
        this.stateLabel = this.stateLabels[0];
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    ngOnInit() {
        if (this.numStates === 2) {
            this.stateLabels = ['stateNull', 'stateTrue'];
            this.statesValues = [false, true];
            if (this.statesValues.indexOf(this.state) === -1) {
                this.state = this.statesValues[0];
            }
        }
        this.setState(this.state);
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    ngOnChanges(changes) {
        if (changes.state && !changes.state.firstChange) {
            this.state = changes.state.currentValue;
            this.setState(this.state);
        }
    }
    setState(stateValue) {
        const index = this.statesValues.indexOf(stateValue);
        this.stateLabel = this.stateLabels[index];
        this.renderer.setProperty(this.input.nativeElement, 'checked', this.stateLabel !== 'stateNull');
    }
    toggleState() {
        const index = this.stateLabels.indexOf(this.stateLabel);
        const newIndex = (index + 1) % this.stateLabels.length;
        this.state = this.statesValues[newIndex];
        this.setState(this.state);
        this.onChange(this.state);
    }
    writeValue(value) {
        this.setState(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormMultiCheckboxComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormMultiCheckboxComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormMultiCheckboxComponent.prototype, "numStates", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormMultiCheckboxComponent.prototype, "input", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormMultiCheckboxComponent.prototype, "messages", void 0);
__decorate([
    ViewChild('labelElement', { static: true }),
    __metadata("design:type", ElementRef)
], FormMultiCheckboxComponent.prototype, "labelElement", void 0);
FormMultiCheckboxComponent = FormMultiCheckboxComponent_1 = __decorate([
    Component({
        selector: 'rb-form-multi-checkbox',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n  <label [for]=\"id + 'input'\" #labelElement [class]=\"stateLabel\">\r\n    <input type=\"checkbox\"\r\n           (change)=\"toggleState()\"\r\n           (blur)=\"onTouched()\"\r\n           class=\"checkbox-control\"\r\n           [id]=\"id + 'input'\"\r\n           #input>\r\n\r\n    <span class=\"checkbox-icon\">\r\n      <span class=\"check rb-ic rb-ic-checkmark\"></span>\r\n      <span class=\"cross rb-ic rb-ic-close\"></span>\r\n    </span>\r\n\r\n    <span class=\"label-text\">\r\n      {{!isLabelTemplate()?label:''}}\r\n      <ng-container *ngIf=\"isLabelTemplate()\">\r\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n      </ng-container>\r\n      <ng-content></ng-content>\r\n    </span>\r\n\r\n  </label>\r\n\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormMultiCheckboxComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2])
], FormMultiCheckboxComponent);

var FormFileComponent_1;
let FormFileComponent = FormFileComponent_1 = class FormFileComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.label = null;
        this.placeholder = '';
        this.filesChange = new EventEmitter();
        this.id = 'file.' + Math.random();
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
        this.filePreview = '';
    }
    checkSelectedFiles() {
        const fileNames = [];
        const files = [];
        for (let i = 0; i < this.file.nativeElement.files.length; i++) {
            const file = this.file.nativeElement.files[i];
            files.push(file);
            if (file.name) {
                fileNames.push(file.name);
            }
        }
        if (files.length === 0) {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        this.filePreview = fileNames.join(', ');
        if (this.filePreview.length > 100) {
            this.filePreview = this.filePreview.substr(0, 97) + '... (' + fileNames.length + ')';
        }
        console.log('files', files);
        this.onChange(files);
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        // console.warn('unsupported write to rb-form-file', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.file.nativeElement, 'disabled', isDisabled);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormFileComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFileComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormFileComponent.prototype, "placeholder", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], FormFileComponent.prototype, "filesChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFileComponent.prototype, "accept", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormFileComponent.prototype, "multiple", void 0);
__decorate([
    ViewChild('file', { static: true }),
    __metadata("design:type", ElementRef)
], FormFileComponent.prototype, "file", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormFileComponent.prototype, "messages", void 0);
FormFileComponent = FormFileComponent_1 = __decorate([
    Component({
        selector: 'rb-form-file',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <input type=\"file\"\r\n         [id]=\"id + 'input'\"\r\n         [placeholder]=\"placeholder\"\r\n         [multiple]=\"multiple !== undefined\"\r\n         [accept]=\"accept\"\r\n         class=\"file-input with-icon\"\r\n         #file\r\n         (change)=\"checkSelectedFiles()\"\r\n         (blur)=\"onTouched()\">\r\n  <span class=\"input-icon no-pointer\">\r\n    <span class=\"rb-ic rb-ic-upload\"></span>\r\n  </span>\r\n\r\n  <label class=\"rb-btn rb-select-btn input\" [for]=\"id + 'input'\">{{filePreview}}</label>\r\n\r\n  <label class=\"label\" [for]=\"id + 'input'\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormFileComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], FormFileComponent);

let FormErrorsComponent = class FormErrorsComponent {
    constructor(control, cd) {
        this.control = control;
        this.cd = cd;
        this.errors = [];
    }
    ngOnInit() {
        if (this.control) {
            this.sub = this.control.statusChanges.subscribe(value => {
                this.errors = this.getErrors();
                this.cd.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    ngDoCheck() {
        this.errors = this.getErrors();
    }
    getErrors() {
        const errors = [];
        if (this.control && this.control.errors && (this.control.touched || this.control.dirty)) {
            const errorKeys = Object.keys(this.control.errors);
            for (const key of errorKeys) {
                const message = this.messages.find(item => item.name === key);
                if (message && (message.onTouched || !message.onTouched && this.control.dirty)) {
                    errors.push({
                        name: key,
                        data: this.control.errors[key],
                        message: message.templateRef
                    });
                }
            }
        }
        return errors;
    }
    getItemName(i, item) {
        return item.name;
    }
};
__decorate([
    Input(),
    __metadata("design:type", QueryList)
], FormErrorsComponent.prototype, "messages", void 0);
FormErrorsComponent = __decorate([
    Component({
        selector: 'rb-form-errors',
        template: "<div class=\"error-messages\" *ngIf=\"control && control.invalid && errors.length\">\n  <div *ngFor=\"let item of errors; trackBy: getItemName\">\n    <ng-container *ngTemplateOutlet=\"item.message; context: item\"></ng-container>\n  </div>\n</div>\n"
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgControl,
        ChangeDetectorRef])
], FormErrorsComponent);

var FormCheckboxRequiredValidatorDirective_1;
/* tslint:disable:directive-selector */
let FormCheckboxRequiredValidatorDirective = FormCheckboxRequiredValidatorDirective_1 = class FormCheckboxRequiredValidatorDirective {
    constructor() {
        this.statesMode = 'check';
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value != null && value !== false && `${value}` !== 'false';
        if (this._onChange) {
            this._onChange();
        }
    }
    validate(c) {
        if (this.required) {
            return this.hasValue(c) ? null : { 'required': true };
        }
        return null;
    }
    hasValue(c) {
        if (typeof (c.value) === 'boolean') {
            return c.value === true;
        }
        if (typeof (c.value) === 'object' && c.value) {
            const values = Object.keys(c.value).map(key => c.value[key]);
            if (this.statesMode === 'optCheck') {
                return values.some(v => v !== null);
            }
            if (this.statesMode === 'check') {
                return values.some(v => v !== false);
            }
        }
        return true;
    }
    registerOnValidatorChange(fn) {
        this._onChange = fn;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormCheckboxRequiredValidatorDirective.prototype, "statesMode", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], FormCheckboxRequiredValidatorDirective.prototype, "required", null);
FormCheckboxRequiredValidatorDirective = FormCheckboxRequiredValidatorDirective_1 = __decorate([
    Directive({
        selector: 'rb-form-checkbox[required],rb-form-multi-select[required]',
        providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FormCheckboxRequiredValidatorDirective_1),
                multi: true
            }]
    }),
    __metadata("design:paramtypes", [])
], FormCheckboxRequiredValidatorDirective);

var FormFileValidatorDirective_1;
/* tslint:disable:directive-selector */
let FormFileValidatorDirective = FormFileValidatorDirective_1 = class FormFileValidatorDirective {
    constructor() {
    }
    ngOnChanges(changes) {
        if (this.onChange && (changes.min || changes.max || changes.maxSize)) {
            this.onChange();
        }
    }
    validate(c) {
        const errors = {};
        const minNumber = this.min ? parseInt(this.min, 10) : 0;
        const maxNumber = this.max ? parseInt(this.max, 10) : 0;
        const maxSize = this.maxSize ? parseInt(this.maxSize, 10) : 0;
        if (minNumber && (!c.value || Array.isArray(c.value) && c.value.length < minNumber)) {
            errors.min = true;
        }
        if (maxNumber && (!c.value || Array.isArray(c.value) && c.value.length > maxNumber)) {
            errors.max = true;
        }
        if (maxSize && Array.isArray(c.value)) {
            c.value.some((file) => {
                if (file.size > maxSize) {
                    errors.maxSize = file.name;
                    return true;
                }
                return false;
            });
        }
        return Object.keys(errors).length ? errors : null;
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFileValidatorDirective.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFileValidatorDirective.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormFileValidatorDirective.prototype, "maxSize", void 0);
FormFileValidatorDirective = FormFileValidatorDirective_1 = __decorate([
    Directive({
        selector: 'rb-form-file[min],rb-form-file[max],rb-form-file[min],rb-form-file[maxSize]',
        providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FormFileValidatorDirective_1),
                multi: true
            }]
    }),
    __metadata("design:paramtypes", [])
], FormFileValidatorDirective);

const FORM_SELECT_SELECTOR = new InjectionToken('formCustomSelectSelectorSubject');

let FormSelectOptionComponent = class FormSelectOptionComponent {
    constructor(selectSubject, elementRef) {
        this.selectSubject = selectSubject;
        this.elementRef = elementRef;
        this.active = false;
    }
    ngOnInit() {
        this.sub = this.selectSubject.subscribe(action => {
            this.active = action.value === this.value;
        });
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    select() {
        this.selectSubject.next({ type: 'update', value: this.value });
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormSelectOptionComponent.prototype, "value", void 0);
__decorate([
    ViewChild('innerLink', { static: true }),
    __metadata("design:type", ElementRef)
], FormSelectOptionComponent.prototype, "content", void 0);
FormSelectOptionComponent = __decorate([
    Component({
        selector: 'rb-form-select-option',
        template: "<a href=\"javascript:\" class=\"rb-dropdown-item\" [class.active]=\"active\" (click)=\"select()\" #innerLink>\r\n  <ng-content></ng-content>\r\n</a>\r\n"
    }),
    __param(0, Inject(FORM_SELECT_SELECTOR)),
    __metadata("design:paramtypes", [Subject,
        ElementRef])
], FormSelectOptionComponent);

var FormCustomSelectComponent_1;
function customSelectSelectorFactory() {
    return new Subject();
}
/**
 * This component offers a select field, that can be heavily customized.
 * The easy way would to just add options like this:
 * <rb-form-select-option [value]=""></rb-form-select-option>
 *
 * But you can also provide a selectionTpl which is a ng-template that is used to show the options in the dropdown.
 * It gets a context, that contains a select() function that can be used to provide the value for the ngModel.
 */
let FormCustomSelectComponent = FormCustomSelectComponent_1 = class FormCustomSelectComponent {
    constructor(renderer, elementRef, selectSubject) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.selectSubject = selectSubject;
        this.label = null;
        this.id = 'customSelectValue.' + Math.random();
        this.selectionTpl = null;
        this.autoClose = true;
        this.isMouseOver = false;
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
        this.value = null;
        this.updateValue = value => {
            this.value = value;
            this.onChange(value);
            this.checkValue(value);
        };
    }
    ngOnInit() {
        this.selectSub = this.selectSubject.subscribe(action => {
            if (action.type === 'update') {
                this.updateValue(action.value);
            }
        });
    }
    ngOnDestroy() {
        if (this.selectSub) {
            this.selectSub.unsubscribe();
        }
    }
    ngAfterViewInit() {
        this.updateCurrentLabel(this.value);
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    mouseover() {
        this.isMouseOver = true;
    }
    mouseleave() {
        this.isMouseOver = false;
    }
    writeValue(value) {
        this.value = value;
        this.selectSubject.next({ type: 'write', value });
        this.checkValue(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    checkValue(value) {
        if (typeof (value) === 'string' && value.length > 0 || typeof (value) === 'number' || typeof (value) === 'boolean' || value) {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
        this.updateCurrentLabel(value);
    }
    updateCurrentLabel(value) {
        if (this.options && this.options.length) {
            const opt = this.options.find(item => item.value === value);
            if (opt) {
                this.activeElement.nativeElement.innerHTML = opt.content.nativeElement.innerHTML;
            }
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], FormCustomSelectComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormCustomSelectComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], FormCustomSelectComponent.prototype, "selectionTpl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormCustomSelectComponent.prototype, "autoClose", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormCustomSelectComponent.prototype, "messages", void 0);
__decorate([
    ContentChild(MultiSelectOptionDirective, { static: false }),
    __metadata("design:type", MultiSelectOptionDirective)
], FormCustomSelectComponent.prototype, "option", void 0);
__decorate([
    ContentChild(MultiSelectTitleDirective, { static: false }),
    __metadata("design:type", MultiSelectTitleDirective)
], FormCustomSelectComponent.prototype, "title", void 0);
__decorate([
    ContentChildren(FormSelectOptionComponent),
    __metadata("design:type", QueryList)
], FormCustomSelectComponent.prototype, "options", void 0);
__decorate([
    ViewChild('activeElement', { static: true }),
    __metadata("design:type", ElementRef)
], FormCustomSelectComponent.prototype, "activeElement", void 0);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormCustomSelectComponent.prototype, "mouseover", null);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormCustomSelectComponent.prototype, "mouseleave", null);
FormCustomSelectComponent = FormCustomSelectComponent_1 = __decorate([
    Component({
        selector: 'rb-form-custom-select',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <button [rbDropdown]=\"dropdownContent\"\r\n          [id]=\"id\"\r\n          [autoClose]=\"autoClose\"\r\n          [disabled]=\"disabled !== undefined\"\r\n          (blur)=\"onTouched()\"\r\n          class=\"rb-select-btn input\">\r\n    <ng-container *ngIf=\"!options.length\">\r\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n    </ng-container>\r\n    <span #activeElement></span>\r\n  </button>\r\n\r\n  <label [for]=\"id\" class=\"label rb-select-label\">\r\n    {{!isLabelTemplate() ? label : ''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"select-icon rb-ic rb-ic-down\"></span>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n\r\n<ng-template #content>\r\n  <ng-content></ng-content>\r\n</ng-template>\r\n\r\n<ng-template #dropdownContent let-close=\"close\">\r\n  <ng-container *ngIf=\"options.length\">\r\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n  </ng-container>\r\n  <ng-container *ngTemplateOutlet=\"selectionTpl; context: {select: updateValue, close: close}\"></ng-container>\r\n</ng-template>\r\n",
        providers: [
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormCustomSelectComponent_1), multi: true },
            { provide: FORM_SELECT_SELECTOR, useFactory: customSelectSelectorFactory }
        ]
    }),
    __param(2, Inject(FORM_SELECT_SELECTOR)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef,
        Subject])
], FormCustomSelectComponent);

var FormChipsInputComponent_1;
let FormChipsInputComponent = FormChipsInputComponent_1 = class FormChipsInputComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.chips = [];
        this.chipInput = '';
        this.id = 'input.' + Math.random();
        this.disabled = false;
        this.activeIndex = null;
        this.mouseIn = false;
        this.deletingLast = false;
        this.label = null;
        this.placeholder = '';
        this.chipAdded = new EventEmitter();
        this.chipDeleted = new EventEmitter();
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    set setFocus(val) {
        if (this.input && 'nativeElement' in this.input) {
            this.input.nativeElement.focus();
        }
    }
    onMouseEnter() {
        this.mouseIn = true;
    }
    onMouseLeave() {
        this.mouseIn = false;
    }
    onAnyClick() {
        if (this.activeIndex !== null && !this.mouseIn) {
            this.activeIndex = null;
        }
    }
    onKeydownHandler(event) {
        if (this.activeIndex !== null && !this.deletingLast && event.key === 'Backspace') {
            event.preventDefault();
            this.removeAtIndex(this.activeIndex);
        }
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        this.chips = value || [];
        this.checkState();
        this.renderer.setProperty(this.input.nativeElement, 'value', '');
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
    checkState() {
        if (this.chips && this.chips.length > 0) {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
    }
    submit() {
        if (this.chipInput !== '') {
            this.addChip(this.chipInput);
            this.chipInput = '';
        }
    }
    onKeyDown(e) {
        if (e.key === 'Backspace' && this.chipInput === '') {
            e.preventDefault();
            if (this.activeIndex !== null) {
                this.removeLast();
                this.checkState();
            }
            else {
                this.deletingLast = true;
                this.activeIndex = this.chips.length - 1;
            }
        }
    }
    onBlur() {
        if (this.chipInput !== '') {
            this.addChip(this.chipInput);
            this.chipInput = '';
        }
        this.onTouched();
    }
    addChip(chip) {
        this.chips.push(chip.trim());
        this.onChange(this.chips);
        this.checkState();
        this.chipAdded.next(chip);
    }
    removeChip(chip) {
        const index = this.chips.indexOf(chip);
        if (index !== -1) {
            this.chips.splice(index, 1);
            this.onChange(this.chips);
            this.checkState();
            this.chipDeleted.next(chip);
        }
    }
    removeLast() {
        const lastChip = this.chips[this.chips.length - 1];
        this.chips.splice(-1, 1);
        this.activeIndex = null;
        this.deletingLast = false;
        this.onChange(this.chips);
        this.chipDeleted.next(lastChip);
    }
    removeAtIndex(i) {
        const chipAtIndex = this.chips[i];
        this.chips.splice(i, 1);
        this.activeIndex = null;
        this.onChange(this.chips);
        this.chipDeleted.next(chipAtIndex);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormChipsInputComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormChipsInputComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], FormChipsInputComponent.prototype, "setFocus", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], FormChipsInputComponent.prototype, "chipAdded", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], FormChipsInputComponent.prototype, "chipDeleted", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormChipsInputComponent.prototype, "messages", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormChipsInputComponent.prototype, "input", void 0);
__decorate([
    ViewChild('chipcontainer', { static: false }),
    __metadata("design:type", ElementRef)
], FormChipsInputComponent.prototype, "chipcontainer", void 0);
__decorate([
    HostListener('mouseenter'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormChipsInputComponent.prototype, "onMouseEnter", null);
__decorate([
    HostListener('mouseleave'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormChipsInputComponent.prototype, "onMouseLeave", null);
__decorate([
    HostListener('window:click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FormChipsInputComponent.prototype, "onAnyClick", null);
__decorate([
    HostListener('document:keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], FormChipsInputComponent.prototype, "onKeydownHandler", null);
FormChipsInputComponent = FormChipsInputComponent_1 = __decorate([
    Component({
        selector: 'rb-form-chips-input',
        template: "<div class=\"input-wrapper d-flex\" [class.no-label]=\"!label\">\r\n  <div class=\"chips\">\r\n    <ng-container *ngFor=\"let chip of chips; let i = index\">\r\n      <div (click)=\"activeIndex = i\" [ngClass]=\"{'disabled': disabled, 'selected': activeIndex === i}\"\r\n           class=\"rb-chip mr-1\">\r\n        <span>{{chip}}</span>\r\n        <a href=\"javascript:\" (click)=\"removeChip(chip)\" style=\"margin-left: 4px;\"><span\r\n          class=\"rb-ic rb-ic-close\"></span></a>\r\n      </div>\r\n    </ng-container>\r\n  </div>\r\n  <form (ngSubmit)=\"submit()\" class=\"flex-grow-1\">\r\n    <input #input class=\"input chips-input\" [id]=\"id\" (click)=\"activeIndex = null\"\r\n           (keydown)=\"onKeyDown($event)\"\r\n           (blur)=\"onBlur()\"\r\n           [(ngModel)]=\"chipInput\"\r\n           [placeholder]=\"placeholder\"\r\n           [ngStyle]=\"{'margin-left': chips.length == 0 ? 0 : '1rem'}\"\r\n           name=\"chipInput\"\r\n           type=\"text\"\r\n           minlength=\"1\">\r\n    <label class=\"label\" [for]=\"id\">{{!isLabelTemplate() ? label : ''}}</label>\r\n    <span class=\"input-background\"></span>\r\n  </form>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormChipsInputComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], FormChipsInputComponent);

var FormChipsInputPatternValidatorDirective_1;
/* tslint:disable:directive-selector */
let FormChipsInputPatternValidatorDirective = FormChipsInputPatternValidatorDirective_1 = class FormChipsInputPatternValidatorDirective {
    constructor() {
    }
    validate(c) {
        let hasInvalid = false;
        if (c.value && this.pattern) {
            c.value.forEach(el => {
                if (!el.match(this.pattern)) {
                    hasInvalid = true;
                }
            });
            if (hasInvalid) {
                return { 'pattern': true };
            }
            else {
                return null;
            }
        }
        return null;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormChipsInputPatternValidatorDirective.prototype, "pattern", void 0);
FormChipsInputPatternValidatorDirective = FormChipsInputPatternValidatorDirective_1 = __decorate([
    Directive({
        selector: 'rb-form-chips-input[pattern]',
        providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FormChipsInputPatternValidatorDirective_1),
                multi: true
            }]
    }),
    __metadata("design:paramtypes", [])
], FormChipsInputPatternValidatorDirective);

var NumberConverterDirective_1;
let NumberConverterDirective = NumberConverterDirective_1 = class NumberConverterDirective {
    modelToValue(model) {
        return model === null || model === undefined ? '' : String(model);
    }
    valueToModel(value) {
        if (value === 'null' || value === '') {
            return null;
        }
        return parseFloat(value);
    }
};
NumberConverterDirective = NumberConverterDirective_1 = __decorate([
    Directive({
        selector: '[rbNumberConverter]',
        providers: [{ provide: CUSTOM_VALUE_CONVERTER, useExisting: forwardRef(() => NumberConverterDirective_1) }]
    })
], NumberConverterDirective);

var JsonConverterDirective_1;
let JsonConverterDirective = JsonConverterDirective_1 = class JsonConverterDirective {
    modelToValue(model) {
        return JSON.stringify(model);
    }
    valueToModel(value) {
        try {
            return JSON.parse(value);
        }
        catch (e) {
            console.warn('Could not parse JSON', value, e);
            return null;
        }
    }
};
JsonConverterDirective = JsonConverterDirective_1 = __decorate([
    Directive({
        selector: '[rbJsonConverter]',
        providers: [{ provide: CUSTOM_VALUE_CONVERTER, useExisting: forwardRef(() => JsonConverterDirective_1) }]
    })
], JsonConverterDirective);

let FormInputAutocompleteListComponent = class FormInputAutocompleteListComponent {
};
__decorate([
    ViewChild('tpl', { static: true }),
    __metadata("design:type", TemplateRef)
], FormInputAutocompleteListComponent.prototype, "template", void 0);
FormInputAutocompleteListComponent = __decorate([
    Component({
        selector: 'rb-form-input-autocomplete-list',
        template: "<ng-template #tpl let-list=\"list\" let-active=\"active\" let-focus=\"focus\" let-select=\"select\">\r\n  <a href=\"javascript:\"\r\n     *ngFor=\"let value of list\" (click)=\"select(value)\"\r\n     class=\"rb-dropdown-item\"\r\n     [class.active]=\"active === value\"\r\n     [class.focus]=\"focus === value\">{{value}}</a>\r\n</ng-template>\r\n"
    })
], FormInputAutocompleteListComponent);

let FormInputAutocompleteDirective = class FormInputAutocompleteDirective extends DropdownDirective {
    constructor(_factoryResolver, injector, viewContainerRef, control, inputs) {
        super(_factoryResolver, viewContainerRef);
        this._factoryResolver = _factoryResolver;
        this.injector = injector;
        this.control = control;
        /**
         * Should the dropdown open on initial click without any value change
         */
        this.rbInitialOpen = false;
        this.rbDebounceTime = 500;
        this.destroy = new Subject();
        this.loading = false;
        this.error = null;
        this.lastResult = null;
        this.focus = null;
        this.input = null;
        this.noSearchFor = null;
        if (inputs) {
            this.input = inputs[0];
        }
        this.openOnClick = false;
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.rbInitialOpen) {
            this.openOnClick = true;
        }
        if (!this.rbAutocompleteList) {
            const factory = this._factoryResolver.resolveComponentFactory(FormInputAutocompleteListComponent);
            const component = factory.create(this.injector);
            this.instance = component.instance;
            this.rbAutocompleteList = component.instance.template;
        }
        this.template = this.rbAutocompleteList;
        this.updateLoading(false, null);
        let changes = 0;
        let resolvedValue = null;
        this.control.valueChanges.pipe(debounceTime(this.rbDebounceTime), switchMap(value => {
            changes++;
            if (changes === 1 && !this.rbInitialOpen || resolvedValue === value || this.noSearchFor === value) {
                return NEVER;
            }
            resolvedValue = value;
            this.updateLoading(true, null);
            const result = this.rbFormInputAutocomplete(value);
            if (result) {
                return result.pipe(tap(() => this.updateLoading(false, null), err => this.updateLoading(false, err), () => this.updateLoading(false, null)), catchError(err => of(null)), takeUntil(this.control.valueChanges.pipe(skip(1))));
            }
            else {
                this.updateLoading(false, null);
                return of(null);
            }
        }), takeUntil(this.destroy)).subscribe(results => {
            this.openOnClick = true;
            this.lastResult = results;
            if (results !== null && !results.includes(resolvedValue)) {
                this.focus = null;
            }
            this.updateContext(this.control.value);
            if (results !== null && (!this.componentRef || !this.componentRef.instance.shown) && changes > 1) {
                this.openDropdown();
            }
            if (results === null) {
                this.closeDropdown();
            }
        });
    }
    ngAfterViewInit() {
        if (this.input && this.input.input) {
            this.input.input.nativeElement.autocomplete = 'off';
        }
    }
    updateLoading(loading, error) {
        this.loading = loading;
        this.error = error;
        if (this.error) {
            const errors = this.control.errors || {};
            errors['autocomplete'] = this.error;
            this.control.control.setErrors(errors);
        }
        if (this.input && this.loading) {
            this.input.updateIcon('rb-ic rb-ic-spin rb-ic-refresh');
        }
        if (this.input && !this.loading) {
            this.input.updateIcon(this.rbInitialOpen ? 'select-icon rb-ic rb-ic-down' : null);
        }
        if (this.input && this.error) {
            this.input.updateIcon('rb-ic rb-ic-alert-warning u-TextColor--red');
        }
    }
    select(value) {
        this.noSearchFor = value;
        this.control.control.setValue(value);
        this.focus = value;
        this.closeDropdown();
        this.updateContext(value);
    }
    onKeyUp(e) {
        if (e.key === 'ArrowDown' || e.key === 'Down') {
            e.preventDefault();
            this.moveFocus(1);
        }
        if (e.key === 'ArrowUp' || e.key === 'Up') {
            e.preventDefault();
            this.moveFocus(-1);
        }
        if (e.key === 'Enter' && this.componentRef && this.componentRef.instance.shown) {
            e.preventDefault();
            this.select(this.focus);
        }
    }
    moveFocus(by) {
        const list = this.lastResult || [];
        if (!list.length) {
            this.focus = null;
            this.updateContext(this.control.value);
            return;
        }
        let focusIndex = list.indexOf(this.focus);
        if (focusIndex === -1) {
            focusIndex = 0;
        }
        else {
            focusIndex += by;
            if (focusIndex === -1) {
                focusIndex = list.length - 1;
            }
            if (focusIndex === list.length) {
                focusIndex = 0;
            }
        }
        this.focus = list[focusIndex];
        this.updateContext(this.control.value);
    }
    updateContext(value) {
        this.context = {
            list: this.lastResult,
            active: value,
            focus: this.focus,
            select: this.select.bind(this)
        };
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.destroy.complete();
        this.input = null;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Function)
], FormInputAutocompleteDirective.prototype, "rbFormInputAutocomplete", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], FormInputAutocompleteDirective.prototype, "rbAutocompleteList", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputAutocompleteDirective.prototype, "rbInitialOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormInputAutocompleteDirective.prototype, "rbDebounceTime", void 0);
__decorate([
    HostListener('keyup', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], FormInputAutocompleteDirective.prototype, "onKeyUp", null);
FormInputAutocompleteDirective = __decorate([
    Directive({
        selector: '[rbFormInputAutocomplete]',
    }),
    __param(3, Self()),
    __param(4, Self()), __param(4, Optional()), __param(4, Inject(NG_VALUE_ACCESSOR)),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        Injector,
        ViewContainerRef,
        NgControl, Array])
], FormInputAutocompleteDirective);

var FormRadioComponent_1;
let FormRadioComponent = FormRadioComponent_1 = class FormRadioComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.id = 'radio.' + Math.random();
        this.label = null;
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    updateValue(isChecked) {
        if (isChecked) {
            this.onChange(this.value);
        }
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        if (value === this.value) {
            this.renderer.setProperty(this.input.nativeElement, 'checked', true);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
    isReadonly() {
        return !!(this.readonly === '' || this.readonly);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FormRadioComponent.prototype, "required", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FormRadioComponent.prototype, "noValidation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormRadioComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormRadioComponent.prototype, "label", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormRadioComponent.prototype, "input", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormRadioComponent.prototype, "messages", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormRadioComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormRadioComponent.prototype, "readonly", void 0);
FormRadioComponent = FormRadioComponent_1 = __decorate([
    Component({
        selector: 'rb-form-radio',
        template: "<div class=\"input-wrapper\">\r\n  <input type=\"radio\" [id]=\"id + 'input'\" [name]=\"name\" [readonly]=\"readonly\"\r\n         (click)=\"updateValue($event.target.checked)\" #input>\r\n  <label [for]=\"id + 'input'\">  {{!isLabelTemplate() ? label : ''}}</label>\r\n</div>\r\n\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormRadioComponent_1), multi: true }]
    }),
    __metadata("design:paramtypes", [Renderer2])
], FormRadioComponent);

var FormNumberValidatorDirective_1;
let FormNumberValidatorDirective = FormNumberValidatorDirective_1 = class FormNumberValidatorDirective {
    constructor() {
    }
    validate(control) {
        if (control.value === '') {
            return null;
        }
        const value = typeof (control.value) === 'number' ? control.value : parseFloat(control.value);
        const errors = {};
        if (this.rbMin !== undefined && value < this.rbMin) {
            errors.rbMin = this.rbMin;
        }
        if (this.rbMax !== undefined && value > this.rbMax) {
            errors.rbMax = this.rbMax;
        }
        return Object.keys(errors).length ? errors : null;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Number)
], FormNumberValidatorDirective.prototype, "rbMin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], FormNumberValidatorDirective.prototype, "rbMax", void 0);
FormNumberValidatorDirective = FormNumberValidatorDirective_1 = __decorate([
    Directive({
        selector: '[rbMin],[rbMax]',
        providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FormNumberValidatorDirective_1),
                multi: true
            }]
    }),
    __metadata("design:paramtypes", [])
], FormNumberValidatorDirective);

let FormFieldsModule = class FormFieldsModule {
};
FormFieldsModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            FormsModule,
            IconModule,
            DropdownModule
        ],
        declarations: [
            FormInputComponent,
            FormValidationMessageDirective,
            FormCheckboxComponent,
            FormRadioComponent,
            FormSelectComponent,
            FormTextareaComponent,
            FormMultiSelectComponent,
            FormMultiCheckboxComponent,
            MultiSelectTitleDirective,
            MultiSelectOptionDirective,
            FormFileComponent,
            FormErrorsComponent,
            FormCheckboxRequiredValidatorDirective,
            FormFileValidatorDirective,
            FormCustomSelectComponent,
            FormChipsInputComponent,
            FormChipsInputPatternValidatorDirective,
            NumberConverterDirective,
            JsonConverterDirective,
            FormSelectOptionComponent,
            FormInputAutocompleteDirective,
            FormInputAutocompleteListComponent,
            FormNumberValidatorDirective
        ],
        entryComponents: [
            FormInputAutocompleteListComponent
        ],
        exports: [
            FormInputComponent,
            FormValidationMessageDirective,
            FormRadioComponent,
            FormCheckboxComponent,
            FormSelectComponent,
            FormTextareaComponent,
            FormMultiSelectComponent,
            FormMultiCheckboxComponent,
            MultiSelectTitleDirective,
            MultiSelectOptionDirective,
            FormFileComponent,
            FormCheckboxRequiredValidatorDirective,
            FormFileValidatorDirective,
            FormCustomSelectComponent,
            FormChipsInputComponent,
            FormChipsInputPatternValidatorDirective,
            NumberConverterDirective,
            JsonConverterDirective,
            FormSelectOptionComponent,
            FormErrorsComponent,
            FormInputAutocompleteDirective,
            FormNumberValidatorDirective
        ]
    })
], FormFieldsModule);

let ModalComponent = class ModalComponent {
    constructor(elementRef, viewContainerRef) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.options = {
            position: 'middle',
            showClose: true,
            backdropClose: true
        };
    }
    ngOnInit() {
        if (this.options.maxWidth) {
            this.elementRef.nativeElement.style.maxWidth = this.options.maxWidth;
        }
        if (this.options.position) {
            this.elementRef.nativeElement.classList.add(this.options.position);
        }
        if (this.contentComponentRef && this.box) {
            this.viewContainerRef.insert(this.contentComponentRef.hostView);
        }
    }
    ngAfterViewInit() {
        if (this.contentComponentRef && this.box) {
            this.box.nativeElement.appendChild(this.contentComponentRef.location.nativeElement);
        }
    }
};
__decorate([
    ViewChild('box', { static: true }),
    __metadata("design:type", ElementRef)
], ModalComponent.prototype, "box", void 0);
ModalComponent = __decorate([
    Component({
        selector: 'rb-modal',
        template: "<div class=\"modal-box\" role=\"dialog\" #box>\n  <button class=\"close-btn rb-btn rb-passive-link\" (click)=\"close()\" *ngIf=\"options.showClose\"><rb-icon name=\"close\"></rb-icon></button>\n\n  <ng-container *ngIf=\"contentTpl\">\n    <ng-container *ngTemplateOutlet=\"contentTpl; context: {close: close}\"></ng-container>\n  </ng-container>\n  <ng-container *ngIf=\"contentComponent\">\n    <ng-container *ngComponentOutlet=\"contentComponent\"></ng-container>\n  </ng-container>\n  {{contentText ? contentText : ''}}\n</div>\n"
    }),
    __metadata("design:paramtypes", [ElementRef, ViewContainerRef])
], ModalComponent);

let ModalService = class ModalService {
    constructor(factoryResolver, injector, appRef) {
        this.factoryResolver = factoryResolver;
        this.injector = injector;
        this.appRef = appRef;
        this.openComponents = [];
        const el = document.querySelector('.rb-modal-backdrop');
        if (el) {
            this.backdrop = el;
        }
        else {
            this.backdrop = document.body.appendChild(document.createElement('div'));
            this.backdrop.className = 'rb-modal-backdrop';
            let isDown = false;
            this.backdrop.addEventListener('mousedown', e => {
                if (e.target === this.backdrop) {
                    isDown = true;
                }
            });
            this.backdrop.addEventListener('mouseup', e => {
                if (isDown && e.target === this.backdrop) {
                    this.nonButtonClose();
                }
                isDown = false;
            });
        }
        this.componentFactory = this.factoryResolver.resolveComponentFactory(ModalComponent);
    }
    get appRoot() {
        return this.appRef.components[0].location.nativeElement;
    }
    /**
     * Opens a component in a modal. Creates the component instance.
     * Provide an injector in case the ModalService is not instantiated with the Injector that knows the Component.
     */
    openComponent(component, options, injector) {
        const factoryResolver = (injector || this.injector).get(ComponentFactoryResolver);
        const factory = factoryResolver.resolveComponentFactory(component);
        const componentRef = factory.create(injector || this.injector);
        const result = this.open(componentRef, options);
        return {
            result: result,
            instance: componentRef.instance
        };
    }
    open(content, options) {
        return new Promise(resolve => {
            if (this.openComponents.length && options && options.stacked) {
                this.lastOpenModalElement().classList.add('hidden');
            }
            else {
                this.close();
            }
            if (!this.openComponents.length) {
                document.body.classList.add('rb-modal-open');
                if (this.appRef.components.length) {
                    this.appRoot.classList.add('rb-modal-frost');
                }
                this.ensureListeners();
            }
            this.backdrop.classList.remove('large-fix');
            const componentRef = this.componentFactory.create(this.injector);
            if (content instanceof TemplateRef) {
                componentRef.instance.contentTpl = content;
            }
            else if (typeof (content) === 'string') {
                componentRef.instance.contentText = content;
            }
            else if (content instanceof ComponentRef) {
                componentRef.instance.contentComponentRef = content;
            }
            else if (typeof (content) === 'function') {
                componentRef.instance.contentComponent = content;
            }
            componentRef.instance.close = this.close.bind(this);
            if (options) {
                Object.assign(componentRef.instance.options, options);
            }
            this.appRef.attachView(componentRef.hostView);
            this.backdrop.appendChild(componentRef.location.nativeElement);
            componentRef.location.nativeElement.focus();
            // Fix for IE
            setTimeout(() => {
                if (componentRef.location.nativeElement.offsetTop < 0) {
                    this.backdrop.classList.add('large-fix');
                }
            }, 10);
            this.openComponents.push({
                componentRef: componentRef,
                onClose: resolve
            });
        });
    }
    close(reason) {
        const openModal = this.openComponents.pop();
        if (!openModal) {
            return;
        }
        this.appRef.detachView(openModal.componentRef.hostView);
        openModal.componentRef.destroy();
        if (!this.openComponents.length) {
            document.body.classList.remove('rb-modal-open');
            if (this.appRef.components.length) {
                this.appRoot.classList.remove('rb-modal-frost');
            }
            this.removeListeners();
        }
        else {
            this.lastOpenModalElement().classList.remove('hidden');
        }
        if (openModal.onClose) {
            openModal.onClose(reason);
        }
    }
    nonButtonClose() {
        const instance = this.lastOpenModalInstance();
        if (instance && instance.options.backdropClose || !instance) {
            this.close();
        }
    }
    ensureListeners() {
        if (!this.keyListener) {
            this.keyListener = e => {
                // ESC pressed
                if (e.key === 'Escape') {
                    this.nonButtonClose();
                }
            };
        }
        document.addEventListener('keyup', this.keyListener, true);
        if (!this.focusListener) {
            this.focusListener = e => {
                // Focus changes
                if (this.appRoot.contains(document.activeElement)) {
                    const firstFocusable = this.backdrop.querySelector('a,button');
                    firstFocusable.focus();
                }
            };
        }
        document.addEventListener('focus', this.focusListener, true);
    }
    removeListeners() {
        if (this.keyListener) {
            document.removeEventListener('keyup', this.keyListener, true);
        }
        if (this.focusListener) {
            document.removeEventListener('focus', this.focusListener, true);
        }
    }
    lastOpenModal() {
        return this.openComponents[this.openComponents.length - 1];
    }
    lastOpenModalElement() {
        const modal = this.lastOpenModal();
        if (modal) {
            return modal.componentRef.location.nativeElement;
        }
    }
    lastOpenModalInstance() {
        const modal = this.lastOpenModal();
        if (modal) {
            return modal.componentRef.instance;
        }
    }
};
ModalService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        Injector,
        ApplicationRef])
], ModalService);

let ModalDirective = class ModalDirective {
    constructor(modalService, factoryResolver, injector, appRef) {
        this.modalService = modalService;
        this.showClose = true;
        this.position = 'middle';
        this.backdropClose = true;
        this.stacked = false;
        if (!this.modalService) {
            this.modalService = new ModalService(factoryResolver, injector, appRef);
        }
    }
    click(event) {
        event.preventDefault();
        this.modalService.open(this.content, {
            showClose: this.showClose,
            position: this.position,
            maxWidth: this.maxWidth,
            backdropClose: this.backdropClose,
            stacked: this.stacked
        });
    }
    set rbModal(content) {
        this.content = content;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], ModalDirective.prototype, "showClose", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ModalDirective.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ModalDirective.prototype, "maxWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ModalDirective.prototype, "backdropClose", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ModalDirective.prototype, "stacked", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], ModalDirective.prototype, "click", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ModalDirective.prototype, "rbModal", null);
ModalDirective = __decorate([
    Directive({
        selector: '[rbModal]'
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [ModalService,
        ComponentFactoryResolver,
        Injector,
        ApplicationRef])
], ModalDirective);

let DialogComponent = class DialogComponent {
    constructor(modalService) {
        this.modalService = modalService;
        this.showButtons = true;
    }
    ngOnInit() {
    }
    close(reason) {
        this.modalService.close(reason);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], DialogComponent.prototype, "dialogTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DialogComponent.prototype, "okBtnLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DialogComponent.prototype, "cancelBtnLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DialogComponent.prototype, "showButtons", void 0);
DialogComponent = __decorate([
    Component({
        selector: 'rb-dialog',
        template: "<h2 class=\"dialog-title\">{{dialogTitle}}</h2>\n<ng-content></ng-content>\n<div class=\"dialog-buttons\" *ngIf=\"showButtons\">\n  <button class=\"rb-btn\" (click)=\"close()\">{{cancelBtnLabel ? cancelBtnLabel : 'Cancel'}}</button>&nbsp;\n  <button class=\"rb-btn rb-primary\" (click)=\"close(true)\">{{okBtnLabel ? okBtnLabel : 'OK'}}</button>\n</div>\n"
    }),
    __metadata("design:paramtypes", [ModalService])
], DialogComponent);

let AlertComponent = class AlertComponent {
    constructor(modalService) {
        this.modalService = modalService;
        this.type = 'success';
    }
    ngOnInit() {
    }
    close(reason) {
        this.modalService.close(reason);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], AlertComponent.prototype, "alertTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AlertComponent.prototype, "okBtnLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AlertComponent.prototype, "cancelBtnLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AlertComponent.prototype, "type", void 0);
AlertComponent = __decorate([
    Component({
        selector: 'rb-alert',
        template: "<rb-icon [name]=\"type + '-filled'\"></rb-icon>\n<h2 class=\"dialog-title\">{{alertTitle}}</h2>\n<div class=\"dialog-text\">\n  <ng-content></ng-content>\n</div>\n<div class=\"dialog-buttons\">\n  <button class=\"rb-btn\" (click)=\"close(true)\" *ngIf=\"okBtnLabel\">{{okBtnLabel}}</button>\n  <button class=\"rb-btn\" (click)=\"close()\" *ngIf=\"cancelBtnLabel\">{{cancelBtnLabel}}</button>\n</div>\n"
    }),
    __metadata("design:paramtypes", [ModalService])
], AlertComponent);

var ModalModule_1;
let ModalModule = ModalModule_1 = class ModalModule {
    static forRoot() {
        return {
            ngModule: ModalModule_1,
            providers: [
                ModalService
            ]
        };
    }
};
ModalModule = ModalModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule,
            IconModule
        ],
        declarations: [
            ModalComponent,
            ModalDirective,
            DialogComponent,
            AlertComponent
        ],
        exports: [
            ModalComponent,
            ModalDirective,
            DialogComponent,
            AlertComponent
        ],
        entryComponents: [
            ModalComponent
        ]
    })
], ModalModule);

let TabPanelTitleDirective = class TabPanelTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
TabPanelTitleDirective = __decorate([
    Directive({
        selector: '[rbTabPanelTitle]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], TabPanelTitleDirective);

let tabItemNum = 0;
let TabPanelItemDirective = class TabPanelItemDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.rbTabPanelItemPosition = 'left';
        this.rbTabPanelItemType = 'tab';
        this.rbTabPanelItemAutoClose = true; // dropdown option
        this.routerLink = null;
        this.active = false;
        this.shown = 0;
        this.titleTpl = null;
        this.titleStr = null;
        this.id = 'tabItem' + (tabItemNum++);
    }
    set titleItem(title) {
        if (title && !this.titleTpl) {
            this.titleTpl = title.templateRef;
        }
    }
    set rbTabPanelItemDetails(details) {
        this.details = details;
    }
    set rbTabPanelItemId(id) {
        this.id = id;
    }
    set rbTabPanelItem(title) {
        if (title instanceof TemplateRef) {
            this.titleTpl = title;
        }
        else {
            this.titleStr = title;
        }
    }
    show() {
        this.active = true;
        this.shown++;
    }
    hide() {
        this.active = false;
    }
    get position() {
        return this.rbTabPanelItemPosition;
    }
    get type() {
        return this.rbTabPanelItemType;
    }
    get autoClose() {
        return this.rbTabPanelItemAutoClose;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], TabPanelItemDirective.prototype, "rbTabPanelItemPosition", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabPanelItemDirective.prototype, "rbTabPanelItemType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabPanelItemDirective.prototype, "rbTabPanelItemAutoClose", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabPanelItemDirective.prototype, "rbTabPanelItemQueryParams", void 0);
__decorate([
    ContentChild(TabPanelTitleDirective, { static: false }),
    __metadata("design:type", TabPanelTitleDirective),
    __metadata("design:paramtypes", [TabPanelTitleDirective])
], TabPanelItemDirective.prototype, "titleItem", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TabPanelItemDirective.prototype, "rbTabPanelItemDetails", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], TabPanelItemDirective.prototype, "rbTabPanelItemId", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TabPanelItemDirective.prototype, "rbTabPanelItem", null);
TabPanelItemDirective = __decorate([
    Directive({
        selector: '[rbTabPanelItem]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], TabPanelItemDirective);

const TAB_PANEL_RESOLVER = new InjectionToken('TabPanelResolver');
/**
 * A very powerful tab panel component.
 * It can handle dynamic tabs, the tab bar can accept all kind of types. See: TabPanelItemType
 * When you provide `outletName`, you should provide your router config with such an entry to enable the outlet routing:
 * children: [{path: ':id', outlet: 'yourOutletName', component: TabPanelComponent}]
 */
let TabPanelComponent = class TabPanelComponent {
    constructor(renderer, element, tabPanelResolver) {
        this.renderer = renderer;
        this.element = element;
        this.tabPanelResolver = tabPanelResolver;
        this.tabChanged = new EventEmitter();
        this.tabItems = [];
        /**
         * Whether tabs that were opened once, should be kept in the DOM
         * when switching away from them. Or should they be removed from
         * DOM when switched to another tab?
         */
        this.destroyTabs = false;
        this.renderHiddenTabs = false;
        this.lastHeight = 0;
    }
    set tabItemsQuery(tabItems) {
        this.tabItems = tabItems.toArray();
        if (this.outletName) {
            this.tabItems.forEach(tabItem => {
                const link = { outlets: {} };
                link.outlets[this.outletName] = [tabItem.id];
                tabItem.routerLink = [link];
            });
        }
        if (this.tabItems.length && this.tabItems.every(tabItem => !tabItem.active)) {
            if (this.tab) {
                this.showTab(this.tab);
            }
            else {
                this.showFirstTab();
            }
        }
        this.tabItemsLeft = this.tabItems.filter(tabItem => tabItem.position === 'left');
        this.tabItemsCenter = this.tabItems.filter(tabItem => tabItem.position === 'center');
        this.tabItemsRight = this.tabItems.filter(tabItem => tabItem.position === 'right');
    }
    ngAfterViewInit() {
        this.onResize();
    }
    ngOnChanges(changes) {
        if (changes.tab && changes.tab.currentValue && !changes.tab.firstChange) {
            const found = this.tabItems.find(tabItem => tabItem.id === changes.tab.currentValue);
            if (found && !found.active) {
                this.showTab(changes.tab.currentValue);
            }
        }
    }
    ngDoCheck() {
        if (this.element && this.element.nativeElement.classList.contains('full-width')) {
            this.onResize();
        }
    }
    showFirstTab() {
        const firstItem = this.tabItems.find(tabItem => tabItem.type === 'tab');
        if (firstItem) {
            this.showTab(firstItem.id);
        }
    }
    /**
     * Can be used to show a certain tab.
     */
    showTab(id) {
        const found = this.tabItems.find(tabItem => tabItem.id === id);
        if (!found) {
            // wait a tick
            setTimeout(() => {
                this.deactivateAndShowTab(id);
            });
        }
        else {
            this.deactivateAndShowTab(id);
        }
    }
    deactivateAndShowTab(id) {
        this.tabItems.forEach(tabItem => {
            if (tabItem.active && tabItem.id !== id) {
                tabItem.hide();
            }
            else if (tabItem.id === id) {
                tabItem.show();
                this.tabChanged.next(id);
            }
        });
    }
    onResize() {
        if (this.panelPlaceholder && this.tabPanel) {
            const tabPanelHeight = this.tabPanel.nativeElement.offsetHeight;
            if (Math.abs(this.lastHeight - tabPanelHeight) > 2) {
                this.lastHeight = tabPanelHeight;
                this.renderer.setStyle(this.panelPlaceholder.nativeElement, 'height', tabPanelHeight + 'px');
            }
        }
    }
};
__decorate([
    Output(),
    __metadata("design:type", Object)
], TabPanelComponent.prototype, "tabChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabPanelComponent.prototype, "tab", void 0);
__decorate([
    ViewChild('panelPlaceholder', { static: true }),
    __metadata("design:type", ElementRef)
], TabPanelComponent.prototype, "panelPlaceholder", void 0);
__decorate([
    ViewChild('tabPanel', { static: true }),
    __metadata("design:type", ElementRef)
], TabPanelComponent.prototype, "tabPanel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabPanelComponent.prototype, "destroyTabs", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabPanelComponent.prototype, "renderHiddenTabs", void 0);
__decorate([
    ContentChildren(TabPanelItemDirective),
    __metadata("design:type", QueryList),
    __metadata("design:paramtypes", [QueryList])
], TabPanelComponent.prototype, "tabItemsQuery", null);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], TabPanelComponent.prototype, "onResize", null);
TabPanelComponent = __decorate([
    Component({
        selector: 'rb-tab-panel',
        template: "<div class=\"tab-panel-container\">\r\n  <div class=\"tab-panel limit\" #tabPanel>\r\n    <rb-navigation type=\"tab\" class=\"tab-panel-left\">\r\n      <ng-container *ngFor=\"let tabItem of tabItemsLeft; template: tabTpl\"></ng-container>\r\n    </rb-navigation>\r\n    <rb-navigation type=\"tab\" class=\"tab-panel-center\">\r\n      <ng-container *ngFor=\"let tabItem of tabItemsCenter; template: tabTpl\"></ng-container>\r\n    </rb-navigation>\r\n    <rb-navigation type=\"tab\" class=\"tab-panel-right\">\r\n      <ng-container *ngFor=\"let tabItem of tabItemsRight; template: tabTpl\"></ng-container>\r\n    </rb-navigation>\r\n  </div>\r\n</div>\r\n<div class=\"tab-panel-placeholder\" #panelPlaceholder></div>\r\n\r\n<ng-container *ngFor=\"let tabItem of tabItems\">\r\n  <div class=\"tab-content\" *ngIf=\"destroyTabs && tabItem.active || !destroyTabs && tabItem.shown || renderHiddenTabs\"\r\n       [hidden]=\"!tabItem.active\">\r\n    <ng-container *ngTemplateOutlet=\"tabItem.templateRef; context: tabItem\"></ng-container>\r\n  </div>\r\n</ng-container>\r\n\r\n<ng-template #tabTpl let-tabItem>\r\n  <ng-container *ngIf=\"tabItem.type === 'dropdown'\">\r\n    <a href=\"javascript:\" class=\"rb-dropdown-toggle\"\r\n       [class.active]=\"tabItem.active\"\r\n       [rbDropdown]=\"tabItem.templateRef\"\r\n       [position]=\"tabItem.position\"\r\n       [autoClose]=\"tabItem.autoClose\">\r\n      <ng-container *ngIf=\"tabItem.titleStr\">\r\n        {{tabItem.titleStr}}\r\n      </ng-container>\r\n      <ng-container *ngIf=\"tabItem.titleTpl\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"tabItem.titleTpl; context: tabItem\"></ng-container>\r\n      </ng-container>\r\n    </a>\r\n  </ng-container>\r\n  <ng-container *ngIf=\"tabItem.type === 'content'\">\r\n    <ng-container *ngIf=\"tabItem.titleStr\">\r\n      {{tabItem.titleStr}}\r\n    </ng-container>\r\n    <ng-container *ngIf=\"tabItem.titleTpl\">\r\n      <ng-container\r\n        *ngTemplateOutlet=\"tabItem.titleTpl; context: tabItem\"></ng-container>\r\n    </ng-container>\r\n    <ng-container\r\n      *ngTemplateOutlet=\"tabItem.templateRef; context: tabItem\"></ng-container>\r\n  </ng-container>\r\n  <ng-container *ngIf=\"tabItem.type === 'custom'\">\r\n    <ng-container *ngIf=\"tabItem.titleStr\">\r\n      {{tabItem.titleStr}}\r\n    </ng-container>\r\n    <ng-container *ngIf=\"tabItem.titleTpl\">\r\n      <ng-container\r\n        *ngTemplateOutlet=\"tabItem.titleTpl; context: tabItem\"></ng-container>\r\n    </ng-container>\r\n  </ng-container>\r\n  <ng-container *ngIf=\"tabItem.type === 'tab'\">\r\n    <a href=\"javascript:\" [class.active]=\"tabItem.active\" (click)=\"showTab(tabItem.id)\">\r\n      <ng-container *ngIf=\"tabItem.titleStr\">\r\n        {{tabItem.titleStr}}\r\n      </ng-container>\r\n      <ng-container *ngIf=\"tabItem.titleTpl\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"tabItem.titleTpl; context: tabItem\"></ng-container>\r\n      </ng-container>\r\n    </a>\r\n  </ng-container>\r\n  <ng-container *ngIf=\"tabItem.type === 'text'\">\r\n    <span class=\"text-item\">\r\n      <ng-container *ngIf=\"tabItem.titleStr\">\r\n        {{tabItem.titleStr}}\r\n      </ng-container>\r\n      <ng-container *ngIf=\"tabItem.titleTpl\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"tabItem.titleTpl; context: tabItem\"></ng-container>\r\n      </ng-container>\r\n    </span>\r\n  </ng-container>\r\n</ng-template>\r\n"
    }),
    __param(2, Optional()), __param(2, Inject(TAB_PANEL_RESOLVER)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object])
], TabPanelComponent);

/**
 * Mocks the Router Outlet
 */
let TabPanelRouterOutletDirective = class TabPanelRouterOutletDirective extends RouterOutlet {
    constructor(_parentContexts, name) {
        super(_parentContexts, null, null, name, null);
        this._parentContexts = _parentContexts;
        this.__activatedRoute = null;
        this._name = name;
    }
    ngOnInit() {
        if (!this.__activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)
            const context = this._parentContexts.getContext(this._name);
            if (context && context.route) {
                if (context.attachRef) {
                    // `attachRef` is populated when there is an existing component to mount
                    this.attach(context.attachRef, context.route);
                }
                else {
                    // otherwise the component defined in the configuration is created
                    this.activateWith(context.route, context.resolver || null);
                }
            }
        }
    }
    get isActivated() {
        return this.__activated;
    }
    get component() {
        if (!this.__activated) {
            throw new Error('Outlet is not activated');
        }
        return null;
    }
    get activatedRoute() {
        if (!this.__activated) {
            throw new Error('Outlet is not activated');
        }
        return this.__activatedRoute;
    }
    get activatedRouteData() {
        if (this.__activatedRoute) {
            return this.__activatedRoute.snapshot.data;
        }
        return {};
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    detach() {
        if (!this.__activated) {
            throw new Error('Outlet is not activated');
        }
        this.__activated = null;
        this.__activatedRoute = null;
        return null;
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    attach(ref, activatedRoute) {
        this.__activated = true;
        this.__activatedRoute = activatedRoute;
        this.onActivate(activatedRoute);
    }
    deactivate() {
        if (this.__activated) {
            this.__activated = false;
            this.__activatedRoute = null;
        }
    }
    activateWith(activatedRoute, resolver) {
        console.log('activateWith', activatedRoute);
        if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
        }
        this.__activatedRoute = activatedRoute;
        this.__activated = true;
        this.onActivate(activatedRoute);
    }
    onActivate(activatedRoute) {
    }
};
TabPanelRouterOutletDirective = __decorate([
    Directive({
        // tslint:disable-next-line
        selector: 'rb-tab-panel-outlet'
    }),
    __param(1, Attribute('name')),
    __metadata("design:paramtypes", [ChildrenOutletContexts, String])
], TabPanelRouterOutletDirective);

let TabPanelModule = class TabPanelModule {
};
TabPanelModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            NavigationModule,
            DropdownModule,
            RouterModule
        ],
        declarations: [
            TabPanelComponent,
            TabPanelItemDirective,
            TabPanelTitleDirective,
            TabPanelRouterOutletDirective
        ],
        exports: [
            TabPanelComponent,
            TabPanelItemDirective,
            TabPanelTitleDirective
        ]
    })
], TabPanelModule);

let SearchResultItemComponent = class SearchResultItemComponent {
    constructor() {
    }
    ngOnInit() {
    }
    isTemplate(source) {
        return source instanceof TemplateRef;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchResultItemComponent.prototype, "page", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchResultItemComponent.prototype, "itemTitle", void 0);
SearchResultItemComponent = __decorate([
    Component({
        selector: 'rb-search-result-item',
        template: "<div class=\"M-Search-SearchResultItem\">\n  <div class=\"M-Search-SearchResultItem__wrapper\">\n    <div class=\"M-Search-SearchResultItem__page\" *ngIf=\"page\">\n      <ng-container *ngIf=\"isTemplate(page)\" ngTemplateOutlet=\"page\"></ng-container>\n      {{ !isTemplate(page) ? page : '' }}\n    </div>\n    <div class=\"M-Search-SearchResultItem__title\">\n      <ng-container *ngIf=\"isTemplate(itemTitle)\" ngTemplateOutlet=\"title\"></ng-container>\n      {{ !isTemplate(itemTitle) ? itemTitle : '' }}\n    </div>\n    <div class=\"M-Search-SearchResultItem__text\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], SearchResultItemComponent);

let SearchResultModule = class SearchResultModule {
};
SearchResultModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            SearchResultItemComponent
        ],
        exports: [
            SearchResultItemComponent
        ]
    })
], SearchResultModule);

let CalloutComponent = class CalloutComponent {
    constructor() {
        this.type = 'error';
        this.icon = ['rb-ic', 'rb-ic-alert-error-filled'];
        this.type2icon = {
            error: 'rb-ic-alert-error-filled',
            success: 'rb-ic-alert-success-filled',
            warning: 'rb-ic-alert-warning-filled',
            info: 'rb-ic-info',
        };
    }
    ngOnChanges(changes) {
        if (changes.type) {
            this.icon = ['rb-ic', this.type2icon[changes.type.currentValue]];
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], CalloutComponent.prototype, "type", void 0);
CalloutComponent = __decorate([
    Component({
        selector: 'rb-callout',
        template: "<div [class]=\"'rb-callout rb-callout-'+type\">\r\n  <span [ngClass]=\"icon\"></span>\r\n  <ng-content></ng-content>\r\n</div>\r\n"
    }),
    __metadata("design:paramtypes", [])
], CalloutComponent);

let CalloutModule = class CalloutModule {
};
CalloutModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            IconModule
        ],
        declarations: [CalloutComponent],
        exports: [CalloutComponent]
    })
], CalloutModule);

/**
 * Can be toggled to provide a state
 * Usage with: rbDetailsToggle #triggerDetails="rbDetailsToggle"
 * Then check triggerDetails.open for the current state
 */
let DetailsToggleDirective = class DetailsToggleDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        this.isOpenChange = new EventEmitter();
        this.open = false;
    }
    set isOpen(state) {
        if (state) {
            this.openDetails();
        }
        else {
            this.closeDetails();
        }
    }
    onClick(e) {
        e.preventDefault();
        if (this.open) {
            this.closeDetails();
            this.isOpenChange.next(this.open);
        }
        else {
            this.openDetails();
            this.isOpenChange.next(this.open);
        }
    }
    openDetails() {
        this.open = true;
        this.viewContainerRef.element.nativeElement.classList.add('open');
    }
    closeDetails() {
        this.open = false;
        this.viewContainerRef.element.nativeElement.classList.remove('open');
    }
};
__decorate([
    Output(),
    __metadata("design:type", Object)
], DetailsToggleDirective.prototype, "isOpenChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], DetailsToggleDirective.prototype, "isOpen", null);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], DetailsToggleDirective.prototype, "onClick", null);
DetailsToggleDirective = __decorate([
    Directive({
        selector: '[rbDetailsToggle]',
        exportAs: 'rbDetailsToggle'
    }),
    __metadata("design:paramtypes", [ViewContainerRef])
], DetailsToggleDirective);

let DetailsToggleModule = class DetailsToggleModule {
};
DetailsToggleModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [DetailsToggleDirective],
        exports: [DetailsToggleDirective]
    })
], DetailsToggleModule);

let TeaserPanelComponent = class TeaserPanelComponent {
    constructor() {
        /**
         * Size of one teaser for the width.
         * Depending on that it is automatically determined how many columns are used
         */
        this.size = 'medium';
    }
    ngOnInit() {
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], TeaserPanelComponent.prototype, "size", void 0);
TeaserPanelComponent = __decorate([
    Component({
        selector: 'rb-teaser-panel',
        template: "<div [class]=\"'teaser-panel teaser-panel-'+size\">\n  <ng-content></ng-content>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], TeaserPanelComponent);

let TeaserPanelItemComponent = class TeaserPanelItemComponent {
    constructor() { }
    ngOnInit() {
    }
};
TeaserPanelItemComponent = __decorate([
    Component({
        selector: 'rb-teaser-panel-item',
        template: "<ng-content></ng-content>\n\n\n"
    }),
    __metadata("design:paramtypes", [])
], TeaserPanelItemComponent);

let TeaserPanelModule = class TeaserPanelModule {
};
TeaserPanelModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [TeaserPanelComponent, TeaserPanelItemComponent],
        exports: [TeaserPanelComponent, TeaserPanelItemComponent]
    })
], TeaserPanelModule);

let BoardItemIconDirective = class BoardItemIconDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
BoardItemIconDirective = __decorate([
    Directive({
        selector: '[rbBoardItemIcon]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], BoardItemIconDirective);
let BoardItemBodyDirective = class BoardItemBodyDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
BoardItemBodyDirective = __decorate([
    Directive({
        selector: '[rbBoardItemBody]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], BoardItemBodyDirective);
let BoardItemCountDirective = class BoardItemCountDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
BoardItemCountDirective = __decorate([
    Directive({
        selector: '[rbBoardItemCount]'
    }),
    __metadata("design:paramtypes", [TemplateRef])
], BoardItemCountDirective);

let BoardItemComponent = class BoardItemComponent {
    constructor() {
    }
    ngOnInit() {
    }
    isTemplateStatus() {
        return this.statusIcon instanceof TemplateRef;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoardItemComponent.prototype, "statusIcon", void 0);
__decorate([
    ContentChild(BoardItemIconDirective, { static: false }),
    __metadata("design:type", BoardItemIconDirective)
], BoardItemComponent.prototype, "icon", void 0);
__decorate([
    ContentChild(BoardItemBodyDirective, { static: false }),
    __metadata("design:type", BoardItemBodyDirective)
], BoardItemComponent.prototype, "body", void 0);
__decorate([
    ContentChildren(BoardItemCountDirective),
    __metadata("design:type", QueryList)
], BoardItemComponent.prototype, "counts", void 0);
BoardItemComponent = __decorate([
    Component({
        selector: 'rb-board-item',
        template: "<div class=\"board-item\">\n  <div class=\"board-item-body\">\n    <div class=\"board-item-icon\" *ngIf=\"icon\">\n      <ng-container *ngTemplateOutlet=\"icon.templateRef\"></ng-container>\n    </div>\n    <div class=\"board-item-content\">\n      <ng-container *ngTemplateOutlet=\"body?.templateRef\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"counts && counts.length\" class=\"board-item-counts\">\n    <ng-container *ngFor=\"let item of counts\">\n      <div class=\"board-item-count\">\n        <ng-container *ngTemplateOutlet=\"item.templateRef\"></ng-container>\n      </div>\n    </ng-container>\n  </div>\n  <div class=\"board-item-status\" *ngIf=\"statusIcon\">\n    <div class=\"board-item-status-icon\">\n      <ng-container *ngIf=\"isTemplateStatus()\">\n        <ng-container *ngTemplateOutlet=\"statusIcon\"></ng-container>\n      </ng-container>\n      <rb-icon *ngIf=\"!isTemplateStatus()\" [name]=\"statusIcon\"></rb-icon>\n    </div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], BoardItemComponent);

let BoardItemModule = class BoardItemModule {
};
BoardItemModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            IconModule
        ],
        declarations: [
            BoardItemComponent,
            BoardItemIconDirective,
            BoardItemBodyDirective,
            BoardItemCountDirective
        ],
        exports: [
            BoardItemComponent,
            BoardItemIconDirective,
            BoardItemBodyDirective,
            BoardItemCountDirective
        ]
    })
], BoardItemModule);

class LoadingEntity {
    constructor(loadingStateAfterFirstSuccess = true) {
        this.loadingStateAfterFirstSuccess = loadingStateAfterFirstSuccess;
        this.runs = 0;
        this.loading = false;
        this.error = null;
        this.result = null;
        this.stopSubject = new Subject();
    }
    /**
     * Tracks the status of an observable
     */
    run(observable) {
        this.runs++;
        if (this.loadingStateAfterFirstSuccess && this.result !== null || this.result === null || this.error) {
            this.loading = true;
            this.result = null;
        }
        this.complete();
        this.error = null;
        return observable.pipe(tap(result => {
            this.loading = false;
            this.result = result;
        }, error => {
            this.loading = false;
            this.error = error;
        }, () => {
            this.loading = false;
        }), takeUntil(this.stopSubject));
    }
    /**
     * This can complete and unsubscribe all observers
     */
    complete() {
        this.stopSubject.next();
    }
    reset() {
        this.complete();
        this.error = null;
        this.loading = false;
        this.result = null;
    }
}

let LoadingStatusComponent = class LoadingStatusComponent {
    constructor() {
        this.size = 1;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], LoadingStatusComponent.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", LoadingEntity)
], LoadingStatusComponent.prototype, "loadingEntity", void 0);
LoadingStatusComponent = __decorate([
    Component({
        selector: 'rb-loading-status',
        template: "<div class=\"centered-container\" *ngIf=\"!loadingEntity?.error\">\n  <rb-loading-spinner [size]=\"size\"></rb-loading-spinner>\n</div>\n<rb-callout *ngIf=\"loadingEntity?.error\">\n  <rb-error-format [error]=\"loadingEntity.error\"></rb-error-format>\n</rb-callout>\n"
    }),
    __metadata("design:paramtypes", [])
], LoadingStatusComponent);

let LoadingDirective = class LoadingDirective {
    constructor(templateRef, viewContainer, componentFactory) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.componentFactory = componentFactory;
        this.loadingRef = null;
        this.viewRef = null;
        this.rbLoadingSize = 1;
    }
    ngDoCheck() {
        if (this.loadingEntity) {
            this.updateView(this.loadingEntity.loading || this.loadingEntity.error);
        }
    }
    set rbLoading(state) {
        this.factory = this.componentFactory.resolveComponentFactory(LoadingStatusComponent);
        this.updateState(state);
    }
    updateState(state) {
        if (state instanceof LoadingEntity) {
            this.loadingEntity = state;
            state = !!(this.loadingEntity.loading || this.loadingEntity.error);
        }
        this.updateView(state);
    }
    updateView(state) {
        if (state) {
            if (!this.loadingRef) {
                this.viewContainer.clear();
                this.viewRef = null;
                this.loadingRef = this.viewContainer.createComponent(this.factory);
                this.loadingRef.instance.loadingEntity = this.loadingEntity;
                this.loadingRef.instance.size = this.rbLoadingSize;
            }
        }
        else {
            if (!this.viewRef) {
                this.viewContainer.clear();
                this.loadingRef = null;
                this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
            }
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], LoadingDirective.prototype, "rbLoadingSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], LoadingDirective.prototype, "rbLoading", null);
LoadingDirective = __decorate([
    Directive({
        selector: '[rbLoading]'
    }),
    __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        ComponentFactoryResolver])
], LoadingDirective);

const ERROR_FORMATTER = new InjectionToken('rbErrorFormatter');
class DetailedError {
    constructor(message, details) {
        this.message = message;
        this.details = details;
        this.name = 'DetailedError';
    }
    toString() {
        return this.message;
    }
}
class DefaultErrorFormatter {
    getDetails(error) {
        if (error instanceof DetailedError) {
            if (typeof (error.details) === 'object') {
                return JSON.stringify(error.details, null, 2);
            }
            return error.details;
        }
        if (error instanceof HttpErrorResponse) {
            if (error.error) {
                if (typeof (error.error) === 'object') {
                    return JSON.stringify(error.error, null, 2);
                }
                return String(error.error);
            }
        }
        return null;
    }
    transform(error) {
        if (error instanceof HttpErrorResponse) {
            let text = 'Error: ';
            if (error.message) {
                text += error.message;
            }
            return text;
        }
        if (error instanceof Error || error instanceof DetailedError) {
            return String(error);
        }
        return null;
    }
}
const DEFAULT_ERROR_FORMATTER = new DefaultErrorFormatter();

/**
 * Formats an error to a string
 */
let ErrorFormatPipe = class ErrorFormatPipe {
    constructor(formatters) {
        if (!formatters) {
            this.formatters = [DEFAULT_ERROR_FORMATTER];
        }
        else {
            this.formatters = formatters.slice();
            this.formatters.push(DEFAULT_ERROR_FORMATTER);
        }
    }
    transform(error, args) {
        if (this.formatters && this.formatters.length) {
            for (let i = 0; i < this.formatters.length; i++) {
                const formatter = this.formatters[i];
                const result = formatter.transform(error);
                if (result !== null) {
                    return result;
                }
            }
        }
        return String(error);
    }
};
ErrorFormatPipe = __decorate([
    Pipe({
        name: 'errorFormat',
        pure: true
    }),
    __param(0, Optional()), __param(0, Inject(ERROR_FORMATTER)),
    __metadata("design:paramtypes", [Array])
], ErrorFormatPipe);

let LoadingLinkDirective = class LoadingLinkDirective {
    constructor(router, element, renderer) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.loading = false;
        this.className = 'loading';
        this.subscription = router.events.subscribe(s => {
            if (s instanceof NavigationStart && this.isRelevantUrl(s.url)) {
                this.loading = true;
                this.update();
            }
            if (s instanceof NavigationEnd) {
                this.loading = false;
                this.update();
            }
        });
    }
    set rbLoadingLink(className) {
        if (className) {
            this.className = className;
        }
    }
    ngAfterContentInit() {
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    update() {
        if (!this.element || !this.element.nativeElement) {
            return;
        }
        if (this.loading) {
            this.renderer.addClass(this.element.nativeElement, this.className);
        }
        else {
            this.renderer.removeClass(this.element.nativeElement, this.className);
        }
    }
    isRelevantUrl(url) {
        return this.linksWithHrefs.some(link => url === link.urlTree.toString());
    }
};
__decorate([
    ContentChildren(RouterLinkWithHref, { descendants: true }),
    __metadata("design:type", QueryList)
], LoadingLinkDirective.prototype, "linksWithHrefs", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], LoadingLinkDirective.prototype, "rbLoadingLink", null);
LoadingLinkDirective = __decorate([
    Directive({
        selector: '[rbLoadingLink]'
    }),
    __metadata("design:paramtypes", [Router, ElementRef, Renderer2])
], LoadingLinkDirective);

let ErrorFormatComponent = class ErrorFormatComponent {
    constructor(formatters) {
        this.opened = false;
        if (!formatters) {
            this.formatters = [DEFAULT_ERROR_FORMATTER];
        }
        else {
            this.formatters = formatters.slice();
            this.formatters.push(DEFAULT_ERROR_FORMATTER);
        }
    }
    ngOnInit() {
        this.identifyErrorData(this.error);
    }
    identifyErrorData(error) {
        if (this.formatters && this.formatters.length) {
            for (let i = 0; i < this.formatters.length; i++) {
                const formatter = this.formatters[i];
                const result = formatter.transform(error);
                if (result !== null) {
                    this.message = result;
                    if (formatter.getDetails) {
                        this.details = formatter.getDetails(error);
                    }
                    return result;
                }
            }
        }
        this.message = String(error);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], ErrorFormatComponent.prototype, "error", void 0);
ErrorFormatComponent = __decorate([
    Component({
        selector: 'rb-error-format',
        template: "<div class=\"error-message\">{{message}}</div>\n<a *ngIf=\"details\" href=\"javascript:\" class=\"rb-link rb-details-toggle\" [class.open]=\"opened\" (click)=\"opened=!opened\">Details</a>\n<pre *ngIf=\"opened\" class=\"error-details\">{{details}}</pre>\n",
        styles: [".error-details{word-wrap:break-word;word-break:break-all;white-space:pre-wrap}"]
    }),
    __param(0, Optional()), __param(0, Inject(ERROR_FORMATTER)),
    __metadata("design:paramtypes", [Array])
], ErrorFormatComponent);

let LoadingModule = class LoadingModule {
};
LoadingModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            LoadingSpinnerModule,
            CalloutModule
        ],
        declarations: [
            LoadingDirective,
            LoadingStatusComponent,
            ErrorFormatPipe,
            LoadingLinkDirective,
            ErrorFormatComponent
        ],
        exports: [
            LoadingDirective,
            LoadingStatusComponent,
            ErrorFormatPipe,
            LoadingLinkDirective,
            ErrorFormatComponent
        ],
        entryComponents: [LoadingStatusComponent]
    })
], LoadingModule);

let AccordionService = class AccordionService {
    constructor() {
        this.updateState = new Subject();
    }
};
AccordionService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], AccordionService);

let AccordionTitleComponent = class AccordionTitleComponent {
    constructor(accordion) {
        this.accordion = accordion;
        this.open = false;
        this.viewInit = false;
    }
    ngOnChanges(changes) {
        if (changes.open && this.viewInit) {
            this.accordion.updateState.next(this);
        }
    }
    ngAfterViewInit() {
        this.viewInit = true;
        if (this.open) {
            setTimeout(() => {
                this.accordion.updateState.next(this);
            });
        }
    }
    toggle() {
        this.open = !this.open;
        this.accordion.updateState.next(this);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionTitleComponent.prototype, "open", void 0);
AccordionTitleComponent = __decorate([
    Component({
        selector: 'rb-accordion-title',
        template: "<div class=\"accordion-row\" [class.open]=\"open\" (click)=\"toggle()\">\r\n  <h5>\r\n    <ng-content></ng-content>\r\n  </h5>\r\n  <a href=\"javascript:\" class=\"accordion-toggle\">\r\n    <span class=\"rb-ic\" [class.rb-ic-add]=\"!open\" [class.rb-ic-less-minimize]=\"open\"></span>\r\n  </a>\r\n</div>\r\n"
    }),
    __metadata("design:paramtypes", [AccordionService])
], AccordionTitleComponent);

let AccordionBodyComponent = class AccordionBodyComponent {
    constructor() {
        this.isOpen = false;
    }
    open() {
        this.isOpen = true;
    }
    close() {
        this.isOpen = false;
    }
};
AccordionBodyComponent = __decorate([
    Component({
        selector: 'rb-accordion-body',
        template: "<div class=\"accordion-body\" [class.open]=\"isOpen\">\r\n  <ng-content></ng-content>\r\n</div>\r\n"
    }),
    __metadata("design:paramtypes", [])
], AccordionBodyComponent);

/**
 * <rb-accordion> is the container for
 * <rb-accordion-title> and <rb-accordion-body>
 */
let AccordionComponent = class AccordionComponent {
    constructor(accordion) {
        this.accordion = accordion;
        /**
         * Whether only one can be opened.
         */
        this.openSingle = false;
        this.updateSub = null;
    }
    ngOnInit() {
        this.updateSub = this.accordion.updateState.subscribe(t => this.updateState(t));
    }
    ngOnDestroy() {
        if (this.updateSub) {
            this.updateSub.unsubscribe();
        }
    }
    updateState(title) {
        const titles = this.titles.toArray();
        const bodies = this.bodies.toArray();
        const index = titles.indexOf(title);
        if (index !== -1) {
            const component = bodies[index];
            if (title.open) {
                component.open();
            }
            else {
                component.close();
            }
            if (this.openSingle) {
                for (let i = 0; i < titles.length; i++) {
                    const title2 = titles[i];
                    const body = bodies[i];
                    if (i !== index && title2.open) {
                        title2.open = false;
                        body.close();
                    }
                }
            }
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionComponent.prototype, "openSingle", void 0);
__decorate([
    ContentChildren(AccordionTitleComponent),
    __metadata("design:type", QueryList)
], AccordionComponent.prototype, "titles", void 0);
__decorate([
    ContentChildren(AccordionBodyComponent),
    __metadata("design:type", QueryList)
], AccordionComponent.prototype, "bodies", void 0);
AccordionComponent = __decorate([
    Component({
        selector: 'rb-accordion',
        template: "<ng-content></ng-content>\r\n",
        providers: [AccordionService]
    }),
    __metadata("design:paramtypes", [AccordionService])
], AccordionComponent);

let AccordionModule = class AccordionModule {
};
AccordionModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [AccordionComponent, AccordionTitleComponent, AccordionBodyComponent],
        exports: [AccordionComponent, AccordionTitleComponent, AccordionBodyComponent]
    })
], AccordionModule);

var FormDateInputComponent_1;
const flatpickrFunc = flatpickrImport; // workaround for rollup and tests
const FLATPICKR_DEFAULT_OPTIONS = new InjectionToken('flatpickrDefaultOptions');
const overridableOptions = {
    time_24hr: true
};
/**
 * Displays a input for flatpickr
 * The value, is a ISO Date String or an array of ISO Date Strings.
 */
let FormDateInputComponent = FormDateInputComponent_1 = class FormDateInputComponent {
    constructor(renderer, elementRef, defaultOptions) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.defaultOptions = defaultOptions;
        this.label = null;
        this.type = 'text';
        this.id = 'input.' + Math.random();
        /**
         * Options for Flatpickr
         * @see https://flatpickr.js.org/options/
         */
        this.options = {};
        /**
         * Given, when this is the start date.
         * Start input is responsible for options
         */
        this.rangeEnd = null;
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
    }
    ngAfterViewInit() {
        if (this.defaultOptions) {
            this.options = Object.assign({}, overridableOptions, this.defaultOptions, this.options);
        }
        else {
            this.options = Object.assign({}, overridableOptions, this.options);
        }
        this.options.onValueUpdate = (selectedDates, dateString) => {
            this.updateValue(selectedDates);
        };
        if (this.rangeEnd) {
            this.rangeEnd.options = Object.assign({}, this.options);
        }
        this.picker = flatpickrFunc(this.input.nativeElement, this.options);
    }
    ngOnChanges(changes) {
        if (changes.options && this.picker && changes.options.currentValue) {
            Object.keys(changes.options.currentValue).forEach(opt => {
                this.picker.set(opt, changes.options.currentValue[opt]);
            });
        }
    }
    ngOnDestroy() {
        if (this.picker) {
            this.picker.destroy();
        }
    }
    isReadonly() {
        return this.readonly !== undefined;
    }
    updateValue(value) {
        if (this.picker.config.mode === 'single' && value && value.length) {
            value = value[0].toISOString();
        }
        if (['range', 'multiple'].indexOf(this.picker.config.mode) !== -1 && value && value.length) {
            value = value.map(v => v.toISOString());
        }
        this.checkValue(value);
        this.onChange(value);
        this.updateEndRange();
    }
    updateEndRange() {
        if (this.rangeEnd && this.picker.selectedDates[0]) {
            const start = this.picker.selectedDates[0];
            const end = this.rangeEnd.picker.selectedDates[0];
            this.rangeEnd.picker.set('minDate', this.picker.selectedDates[0]);
            if (start && end && end.getTime() < start.getTime()) {
                this.rangeEnd.writeValue(start.toISOString());
            }
        }
    }
    checkValue(value) {
        if (typeof (value) === 'string' && value.length > 0 || value && value.length) {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        if (value === null || value === undefined) {
            value = '';
        }
        this.checkValue(value);
        if (this.picker && this.picker.config) {
            this.picker.setDate(value);
        }
        this.updateEndRange();
        // this.renderer.setProperty(this.input.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
    toggle() {
        this.picker.toggle();
    }
    close() {
        this.picker.close();
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateInputComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormDateInputComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateInputComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateInputComponent.prototype, "readonly", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormDateInputComponent.prototype, "messages", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormDateInputComponent.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateInputComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", FormDateInputComponent)
], FormDateInputComponent.prototype, "rangeEnd", void 0);
FormDateInputComponent = FormDateInputComponent_1 = __decorate([
    Component({
        selector: 'rb-form-date-input',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <input [type]=\"type\" [id]=\"id + 'input'\"\r\n         class=\"input with-icon\"\r\n         (blur)=\"onTouched()\"\r\n         [readonly]=\"isReadonly()\"\r\n         #input>\r\n  <span class=\"input-icon rb-ic rb-ic-calendar\" (click)=\"toggle()\"></span>\r\n  <label class=\"label\" [for]=\"id + 'input'\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormDateInputComponent_1), multi: true }],
        exportAs: 'dateInput'
    }),
    __param(2, Optional()), __param(2, Inject(FLATPICKR_DEFAULT_OPTIONS)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object])
], FormDateInputComponent);

const defaultTimeInputOptions = {
    units: [
        { value: 1, unit: 'ms', label: 'Milliseconds' },
        { value: 1000, unit: 's', label: 'Seconds' },
        { value: 1000 * 60, unit: 'm', label: 'Minutes' },
        { value: 1000 * 60 * 60, unit: 'h', label: 'Hours' },
        { value: 1000 * 60 * 60 * 24, unit: 'd', label: 'Days' },
        { value: 1000 * 60 * 60 * 24 * 7, unit: 'w', label: 'Weeks' },
    ]
};
function isRelative(values) {
    return Array.isArray(values) && typeof (values[0]) === 'number' && typeof (values[1]) === 'number';
}
function isAbsolute(values) {
    return Array.isArray(values) && typeof (values[0]) === 'string' && typeof (values[1]) === 'string';
}
function getRelativeInfo(value, units) {
    let operator = '-';
    let count = 0;
    let unit = 'ms';
    if (typeof (value) === 'string' && value.match(/^([+-])(\d+)/)) {
        operator = RegExp.$1;
        count = parseInt(RegExp.$2, 10);
    }
    if (typeof (value) === 'number') {
        operator = value < 0 ? '-' : '+';
        count = Math.abs(value);
    }
    if (count > 0) {
        let divisor = 1;
        units.forEach(u => {
            if (count % u.value === 0) {
                unit = u.unit;
                divisor = u.value;
            }
        });
        count = count / divisor;
    }
    const label = units.find(u => u.unit === unit).label;
    return {
        operator: operator,
        count: count,
        unit: unit,
        label: label,
        displayTextShort: `${operator}${count}${unit}`,
        displayText: `${operator}${count} ${label}`
    };
}

var RelativeTimeInputComponent_1;
const TIME_INPUT_OPTIONS = new InjectionToken('formRelativeInputTimeOptions');
let RelativeTimeInputComponent = RelativeTimeInputComponent_1 = class RelativeTimeInputComponent {
    constructor(options) {
        this.options = options;
        this.id = 'input.' + Math.random();
        this.onChange = emptyFunction$1;
        this.onTouched = emptyFunction$1;
        this.disabled = false;
        this.operator = '-';
        this.count = '0';
        this.unit = 'ms';
        this.displayText = '';
        if (!options) {
            this.options = defaultTimeInputOptions;
        }
    }
    ngOnInit() {
        this.units = defaultTimeInputOptions.units;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    writeValue(obj) {
        const info = getRelativeInfo(obj, this.units);
        this.count = info.count.toString();
        this.operator = info.operator;
        this.unit = info.unit;
        this.displayText = info.displayText;
    }
    getValue() {
        const count = parseInt(this.count, 10) * this.getDivisor();
        if (isNaN(count)) {
            return 0;
        }
        else {
            return this.operator === '-' ? count * -1 : count;
        }
    }
    getDivisor() {
        return this.units.find(u => u.unit === this.unit).value;
    }
    notifyChange() {
        const value = this.getValue();
        this.onChange(value);
    }
    updateUnit(unit) {
        const oldDivisor = this.getDivisor();
        this.unit = unit;
        const newDivisor = this.getDivisor();
        if (newDivisor > oldDivisor) {
            const baseValue = parseInt(this.count, 10) * oldDivisor;
            this.count = Math.ceil(baseValue / newDivisor).toString();
        }
        this.notifyChange();
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], RelativeTimeInputComponent.prototype, "label", void 0);
RelativeTimeInputComponent = RelativeTimeInputComponent_1 = __decorate([
    Component({
        selector: 'rb-form-relative-time-input',
        template: "<div class=\"rb-custom-input\">\r\n  <div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n    <div class=\"relative-time-form\">\r\n      <rb-form-select [(ngModel)]=\"operator\" (ngModelChange)=\"notifyChange()\" name=\"operator\" [disabled]=\"disabled\">\r\n        <option value=\"-\">-</option>\r\n        <option value=\"+\">+</option>\r\n      </rb-form-select>\r\n      <rb-form-input class=\"relative-time-form-number\" type=\"number\"\r\n                     [(ngModel)]=\"count\" (ngModelChange)=\"notifyChange()\" name=\"count\"\r\n                     pattern=\"^\\d+$\" required\r\n                     [disabled]=\"disabled\"></rb-form-input>\r\n      <rb-form-select class=\"relative-time-form-unit\" [disabled]=\"disabled\"\r\n                      [ngModel]=\"unit\"\r\n                      (ngModelChange)=\"updateUnit($event)\"\r\n                      name=\"unit\">\r\n        <option *ngFor=\"let u of units\" [value]=\"u.unit\">{{u.label}}</option>\r\n      </rb-form-select>\r\n    </div>\r\n\r\n    <label class=\"label\" [for]=\"id + 'input'\">\r\n      {{!isLabelTemplate()?label:''}}\r\n      <ng-container *ngIf=\"isLabelTemplate()\">\r\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n      </ng-container>\r\n    </label>\r\n\r\n    <span class=\"input-background\"></span>\r\n\r\n  </div>\r\n</div>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RelativeTimeInputComponent_1), multi: true }]
    }),
    __param(0, Inject(TIME_INPUT_OPTIONS)), __param(0, Optional()),
    __metadata("design:paramtypes", [Object])
], RelativeTimeInputComponent);
function emptyFunction$1(_) {
}

var FormDateRangeInputComponent_1;
const flatpickrFunc$1 = flatpickrImport; // workaround for rollup and tests
const overridableOptions$1 = {
    time_24hr: true
};
let FormDateRangeInputComponent = FormDateRangeInputComponent_1 = class FormDateRangeInputComponent {
    constructor(renderer, elementRef, defaultOptions, timeInputOptions) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.defaultOptions = defaultOptions;
        this.timeInputOptions = timeInputOptions;
        this.label = null;
        this.id = 'input.' + Math.random();
        this.allowRelative = false;
        this.presets = [];
        this.startLabel = 'Start';
        this.endLabel = 'End';
        this.absoluteLabel = 'Absolute';
        this.relativeLabel = 'Relative';
        this.presetsLabel = 'Presets';
        this.displayValue = '';
        /**
         * Options for Flatpickr
         * @see https://flatpickr.js.org/options/
         */
        this.options = {};
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
        this.viewInit = false;
        if (!timeInputOptions) {
            this.timeInputOptions = defaultTimeInputOptions;
        }
    }
    ngAfterViewInit() {
        this.viewInit = true;
        if (isAbsolute(this.value)) {
            this.initPicker();
        }
    }
    ngOnChanges(changes) {
        if (changes.options && this.picker && changes.options.currentValue) {
            Object.keys(changes.options.currentValue).forEach(opt => {
                this.picker.set(opt, changes.options.currentValue[opt]);
            });
        }
    }
    ngOnDestroy() {
        if (this.picker) {
            this.picker.destroy();
        }
    }
    initPicker() {
        if (this.defaultOptions) {
            this.options = Object.assign({}, overridableOptions$1, this.defaultOptions, this.options, { mode: 'range', clickOpens: false });
        }
        else {
            this.options = Object.assign({}, overridableOptions$1, this.options, { mode: 'range', clickOpens: false });
        }
        this.picker = flatpickrFunc$1(this.input.nativeElement, this.options);
        if (this.value) {
            this.picker.setDate(this.value);
        }
    }
    isReadonly() {
        return this.readonly !== undefined;
    }
    updateValue(value) {
        this.value = value;
        this.updateTimeDisplay(value);
        this.checkValue(value);
        this.onChange(value);
    }
    checkValue(value) {
        if (value && value.length) {
            this.renderer.addClass(this.elementRef.nativeElement, 'not-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'not-empty');
        }
    }
    isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    writeValue(value) {
        this.value = value;
        this.updateTimeDisplay(value);
    }
    updateTimeDisplay(value) {
        if (isAbsolute(value)) {
            this.renderer.setProperty(this.input.nativeElement, 'value', '');
            if (this.viewInit && !this.picker) {
                this.initPicker();
            }
            else if (this.picker) {
                this.picker.setDate(value);
            }
        }
        if (isRelative(value)) {
            const info1 = getRelativeInfo(value[0], this.timeInputOptions.units);
            const info2 = getRelativeInfo(value[1], this.timeInputOptions.units);
            this.displayValue = info1.displayText + (info2.count ? ' - ' + info2.displayText : '');
            this.renderer.setProperty(this.input.nativeElement, 'value', this.displayValue);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FormDateRangeInputComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "allowRelative", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], FormDateRangeInputComponent.prototype, "presets", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "startLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "endLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "absoluteLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "relativeLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "presetsLabel", void 0);
__decorate([
    ContentChildren(FormValidationMessageDirective),
    __metadata("design:type", QueryList)
], FormDateRangeInputComponent.prototype, "messages", void 0);
__decorate([
    ViewChild('input', { static: true }),
    __metadata("design:type", ElementRef)
], FormDateRangeInputComponent.prototype, "input", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FormDateRangeInputComponent.prototype, "options", void 0);
FormDateRangeInputComponent = FormDateRangeInputComponent_1 = __decorate([
    Component({
        selector: 'rb-form-date-range-input',
        template: "<div class=\"input-wrapper\" [class.no-label]=\"!label\">\r\n\r\n  <input [id]=\"id + 'input'\"\r\n         class=\"input with-icon\"\r\n         (blur)=\"onTouched()\"\r\n         [rbDropdown]=\"dropdown\"\r\n         [autoClose]=\"false\"\r\n         [hugContent]=\"true\"\r\n         [readonly]=\"isReadonly()\"\r\n         [value]=\"displayValue\"\r\n         #input>\r\n  <span class=\"input-icon rb-ic rb-ic-calendar\"></span>\r\n  <label class=\"label\" [for]=\"id + 'input'\">\r\n    {{!isLabelTemplate()?label:''}}\r\n    <ng-container *ngIf=\"isLabelTemplate()\">\r\n      <ng-container *ngTemplateOutlet=\"label\"></ng-container>\r\n    </ng-container>\r\n  </label>\r\n  <span class=\"input-background\"></span>\r\n</div>\r\n<rb-form-errors [messages]=\"messages\"></rb-form-errors>\r\n\r\n<ng-template #dropdown>\r\n  <rb-date-range-picker [options]=\"options\"\r\n                        [name]=\"name\"\r\n                        [ngModel]=\"value\"\r\n                        (ngModelChange)=\"updateValue($event)\"\r\n                        [allowRelative]=\"allowRelative\"\r\n                        [startLabel]=\"startLabel\"\r\n                        [endLabel]=\"endLabel\"\r\n                        [absoluteLabel]=\"absoluteLabel\"\r\n                        [relativeLabel]=\"relativeLabel\"\r\n                        [presetsLabel]=\"presetsLabel\"\r\n                        [presets]=\"presets\"\r\n  ></rb-date-range-picker>\r\n</ng-template>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => FormDateRangeInputComponent_1), multi: true }]
    }),
    __param(2, Optional()), __param(2, Inject(FLATPICKR_DEFAULT_OPTIONS)),
    __param(3, Optional()), __param(3, Inject(TIME_INPUT_OPTIONS)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object, Object])
], FormDateRangeInputComponent);

var DateRangePickerComponent_1;
const flatpickrFunc$2 = flatpickrImport; // workaround for rollup and tests
const overridableOptions$2 = {
    time_24hr: true,
};
const enforcedOptions = {
    inline: true,
    mode: 'single'
};
let DateRangePickerComponent = DateRangePickerComponent_1 = class DateRangePickerComponent {
    constructor(renderer, elementRef, defaultOptions) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.defaultOptions = defaultOptions;
        this.allowRelative = false;
        this.presets = [];
        this.startLabel = 'Start';
        this.endLabel = 'End';
        this.absoluteLabel = 'Absolute';
        this.relativeLabel = 'Relative';
        this.presetsLabel = 'Presets';
        this.tab = 'absolute';
        this.mode = 'absolute';
        /**
         * Options for Flatpickr
         * @see https://flatpickr.js.org/options/
         */
        this.options = {};
        this.onChange = emptyFunction;
        this.onTouched = emptyFunction;
        this.absoluteValue = null;
        this.initialTabChange = true;
        this.relativeValue = null;
        this.lastModified = null;
    }
    ngOnInit() {
        if (this.defaultOptions) {
            this.options = Object.assign({}, overridableOptions$2, this.defaultOptions, this.options, enforcedOptions);
        }
        else {
            this.options = Object.assign({}, overridableOptions$2, this.options, enforcedOptions);
        }
    }
    ngOnDestroy() {
        if (this.pickerStart) {
            this.pickerStart.destroy();
        }
        if (this.pickerEnd) {
            this.pickerEnd.destroy();
        }
    }
    set initStartDateElement(el) {
        if (!el || el.nativeElement._flatpickr) {
            return;
        }
        const startOptions = Object.assign({}, this.options, { onValueUpdate: (selectedDates) => {
                const start = toISOString(selectedDates[0]);
                this.pickerEnd.set('minDate', selectedDates[0]);
                const end = toISOString(this.pickerEnd.selectedDates[0]);
                this.updateAbsoluteValueFromPicker([start, end]);
            } });
        this.pickerStart = flatpickrFunc$2(el.nativeElement, startOptions);
    }
    set initEndDateElement(el) {
        if (!el || el.nativeElement._flatpickr) {
            return;
        }
        const endOptions = Object.assign({}, this.options, { onValueUpdate: (selectedDates) => {
                const start = toISOString(this.pickerStart.selectedDates[0]);
                const end = toISOString(selectedDates[0]);
                this.updateAbsoluteValueFromPicker([start, end]);
            } });
        this.pickerEnd = flatpickrFunc$2(el.nativeElement, endOptions);
        this.updatePicker();
    }
    tabChanged(tabId) {
        if (this.initialTabChange || this.tab === tabId) {
            this.initialTabChange = false;
            return;
        }
        this.tab = tabId;
        if (tabId === 'absolute') {
            this.mode = 'absolute';
            this.notifyChange(this.absoluteValue);
        }
        if (tabId === 'relative') {
            this.mode = 'relative';
            this.notifyChange(this.relativeValue);
        }
    }
    updateAbsoluteValueFromPicker(value) {
        if (this.tab !== 'absolute'
            || this.absoluteValue && this.absoluteValue[0] === value[0] && this.absoluteValue[1] === value[1]) {
            return;
        }
        this.absoluteValue = value;
        this.relativeValue = this.getRelativeFromAbsolute(value);
        this.notifyChange(value);
    }
    updateRelativeValue(value, index) {
        if (index === 0) {
            this.relativeValue = [value, this.relativeValue[1]];
        }
        if (index === 1) {
            this.relativeValue = [this.relativeValue[0], value];
        }
        this.absoluteValue = getAbsoluteFromRelative(this.relativeValue);
        this.updatePicker();
        this.notifyChange(this.relativeValue);
    }
    notifyChange(value) {
        if (value === this.lastModified || isEqual(value, this.lastModified)) {
            return;
        }
        this.lastModified = value;
        this.onChange(value);
    }
    writeValue(value) {
        if (this.allowRelative && isRelative(value)) {
            this.mode = 'relative';
            this.tab = 'relative';
            this.relativeValue = value;
            this.absoluteValue = getAbsoluteFromRelative(this.relativeValue);
            if (this.findPreset(this.relativeValue)) {
                this.tab = 'preset';
            }
        }
        else if (isAbsolute(value)) {
            this.mode = 'absolute';
            this.tab = 'absolute';
            this.relativeValue = this.getRelativeFromAbsolute(value);
            this.absoluteValue = value;
            if (this.findPreset(this.absoluteValue)) {
                this.tab = 'preset';
            }
        }
        this.lastModified = value;
        this.updatePicker();
    }
    updatePicker() {
        const value = this.absoluteValue;
        if (!value) {
            return;
        }
        if (this.pickerStart && this.pickerStart.config) {
            this.pickerStart.setDate(value[0]);
        }
        if (this.pickerEnd && this.pickerEnd.config) {
            this.pickerEnd.setDate(value[1]);
            this.pickerEnd.set('minDate', value[0]);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        // this.renderer.setProperty(this.input.nativeElement, 'disabled', isDisabled);
    }
    findPreset(value) {
        if (!this.presets) {
            return null;
        }
        if (isAbsolute(value)) {
            return this.presets.filter(p => p.absoluteRange).find(p => isEqual(p.absoluteRange, value));
        }
        else if (isRelative(value)) {
            return this.presets.filter(p => p.relativeRange).find(p => isEqual(p.relativeRange, value));
        }
    }
    isPreset(p) {
        return p.absoluteRange && this.absoluteValue && isEqual(this.absoluteValue, p.absoluteRange)
            || p.relativeRange && this.relativeValue && isEqual(this.relativeValue, p.relativeRange);
    }
    setPreset(preset) {
        if (preset.relativeRange) {
            this.relativeValue = preset.relativeRange;
            this.absoluteValue = getAbsoluteFromRelative(this.relativeValue);
            // this.tab = 'relative';
            this.updatePicker();
            this.notifyChange(this.relativeValue);
        }
        if (preset.absoluteRange) {
            this.absoluteValue = preset.absoluteRange;
            this.relativeValue = this.getRelativeFromAbsolute(this.absoluteValue);
            // this.tab = 'absolute';
            this.updatePicker();
            this.notifyChange(this.absoluteValue);
        }
    }
    getRelativeFromAbsolute(value, byDay = false) {
        const hf = this.options.enableTime && !byDay ? 60 * 60 * 1000 : 24 * 60 * 60 * 1000;
        const now = Math.floor(new Date().getTime() / hf) * hf;
        const start = Math.floor(new Date(value[0]).getTime() / hf) * hf;
        const end = Math.floor(new Date(value[1]).getTime() / hf) * hf;
        if (!byDay && Math.abs((start - now) / hf) > 48) {
            return this.getRelativeFromAbsolute(value, true);
        }
        return [start - now, end - now];
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "readonly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "allowRelative", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], DateRangePickerComponent.prototype, "presets", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "startLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "endLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "absoluteLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "relativeLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "presetsLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DateRangePickerComponent.prototype, "options", void 0);
__decorate([
    ViewChild('startDate', { static: false }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateRangePickerComponent.prototype, "initStartDateElement", null);
__decorate([
    ViewChild('endDate', { static: false }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DateRangePickerComponent.prototype, "initEndDateElement", null);
DateRangePickerComponent = DateRangePickerComponent_1 = __decorate([
    Component({
        selector: 'rb-date-range-picker',
        template: "<rb-tab-panel [renderHiddenTabs]=\"true\" (tabChanged)=\"tabChanged($event)\" [tab]=\"tab\">\r\n  <div *rbTabPanelItem=\"absoluteLabel; id: 'absolute'\" class=\"picker-calendars\">\r\n    <div class=\"startDate\" #startDate></div>\r\n    <div class=\"endDate\" #endDate></div>\r\n  </div>\r\n  <ng-container *ngIf=\"allowRelative\">\r\n    <div *rbTabPanelItem=\"relativeLabel; id: 'relative'\" class=\"picker-relative\">\r\n      <ng-container *ngIf=\"relativeValue\">\r\n        <rb-form-relative-time-input [label]=\"startLabel\" [ngModel]=\"relativeValue[0]\"\r\n                                     (ngModelChange)=\"updateRelativeValue($event, 0)\"></rb-form-relative-time-input>\r\n        <rb-form-relative-time-input [label]=\"endLabel\" [ngModel]=\"relativeValue[1]\"\r\n                                     (ngModelChange)=\"updateRelativeValue($event, 1)\"></rb-form-relative-time-input>\r\n      </ng-container>\r\n\r\n    </div>\r\n  </ng-container>\r\n  <ng-container *ngIf=\"presets?.length\">\r\n    <div *rbTabPanelItem=\"presetsLabel; id: 'preset'\">\r\n      <div *ngFor=\"let p of presets\">\r\n        <ng-container *ngIf=\"allowRelative && p.relativeRange || p.absoluteRange\">\r\n          <a href=\"javascript:\" class=\"rb-dropdown-item\" [class.active]=\"isPreset(p)\" (click)=\"setPreset(p)\">{{p.label}}</a>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n</rb-tab-panel>\r\n",
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateRangePickerComponent_1), multi: true }]
    }),
    __param(2, Optional()), __param(2, Inject(FLATPICKR_DEFAULT_OPTIONS)),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef, Object])
], DateRangePickerComponent);
function toISOString(data) {
    if (typeof data === 'string' || typeof data === 'number') {
        return new Date(data).toISOString();
    }
    else if (data instanceof Date) {
        return data.toISOString();
    }
    return '';
}
function getAbsoluteFromRelative(value) {
    const now = new Date().getTime();
    const start = toISOString(now + value[0]);
    const end = toISOString(now + value[1]);
    return [start, end];
}
function isEqual(value1, value2) {
    return value1 === value2 || value1[0] === value2[0] && value1[1] === value2[1];
}

let FormDateFieldsModule = class FormDateFieldsModule {
};
FormDateFieldsModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            FormsModule,
            IconModule,
            DropdownModule,
            FormFieldsModule,
            TabPanelModule
        ],
        declarations: [
            FormDateInputComponent,
            FormDateRangeInputComponent,
            DateRangePickerComponent,
            RelativeTimeInputComponent
        ],
        exports: [
            FormDateInputComponent,
            FormDateRangeInputComponent,
            DateRangePickerComponent,
            RelativeTimeInputComponent
        ]
    })
], FormDateFieldsModule);

let ProgressIndicatorComponent = class ProgressIndicatorComponent {
    constructor() {
        this.total = Infinity;
        this.current = Infinity;
    }
    ngOnInit() {
    }
    get percent() {
        return this.total > 0 && this.total !== Infinity ? this.current / this.total * 100 : 100;
    }
    get isDeterminate() {
        return this.total !== Infinity;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressIndicatorComponent.prototype, "total", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ProgressIndicatorComponent.prototype, "current", void 0);
ProgressIndicatorComponent = __decorate([
    Component({
        selector: 'rb-progress-indicator',
        template: "<div class=\"progress-container\" [class.noanim]=\"isDeterminate\">\n  <div class=\"progress-current\" [style.width]=\"percent + '%'\">\n    <div class=\"progress-gradient\"></div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [])
], ProgressIndicatorComponent);

let ProgressIndicatorModule = class ProgressIndicatorModule {
};
ProgressIndicatorModule = __decorate([
    NgModule({
        declarations: [ProgressIndicatorComponent],
        exports: [ProgressIndicatorComponent],
        imports: [
            CommonModule
        ]
    })
], ProgressIndicatorModule);

let RbUiComponentsModule = class RbUiComponentsModule {
};
RbUiComponentsModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            FullHeaderModule,
            IconModule,
            PopoverModule,
            FooterNavModule,
            DropdownModule,
            LanguageSelectorModule,
            LoadingSpinnerModule,
            BreadcrumbsModule,
            FormFieldsModule,
            ModalModule,
            TabPanelModule,
            NavigationModule,
            SearchResultModule,
            CalloutModule,
            DetailsToggleModule,
            TeaserPanelModule,
            BoardItemModule,
            LoadingModule,
            AccordionModule,
            FormDateFieldsModule,
            ProgressIndicatorModule
        ],
        exports: [
            FullHeaderModule,
            IconModule,
            PopoverModule,
            FooterNavModule,
            DropdownModule,
            LanguageSelectorModule,
            LoadingSpinnerModule,
            BreadcrumbsModule,
            FormFieldsModule,
            ModalModule,
            TabPanelModule,
            NavigationModule,
            SearchResultModule,
            CalloutModule,
            DetailsToggleModule,
            TeaserPanelModule,
            BoardItemModule,
            LoadingModule,
            AccordionModule,
            FormDateFieldsModule,
            ProgressIndicatorModule
        ]
    })
], RbUiComponentsModule);

export { AccordionBodyComponent, AccordionComponent, AccordionModule, AccordionService, AccordionTitleComponent, ActionNavItemsDirective, AlertComponent, BoardItemBodyDirective, BoardItemComponent, BoardItemCountDirective, BoardItemIconDirective, BoardItemModule, BreadcrumbsComponent, BreadcrumbsModule, BreadcrumbsService, CUSTOM_VALUE_CONVERTER, CalloutComponent, CalloutModule, DEFAULT_ERROR_FORMATTER, DateRangePickerComponent, DefaultErrorFormatter, DetailedError, DetailsToggleDirective, DetailsToggleModule, DialogComponent, DropdownComponent, DropdownDirective, DropdownModule, ERROR_FORMATTER, ErrorFormatComponent, ErrorFormatPipe, FLATPICKR_DEFAULT_OPTIONS, FORM_SELECT_SELECTOR, FooterNavComponent, FooterNavModule, FormCheckboxComponent, FormCheckboxRequiredValidatorDirective, FormChipsInputComponent, FormChipsInputPatternValidatorDirective, FormCustomSelectComponent, FormDateFieldsModule, FormDateInputComponent, FormDateRangeInputComponent, FormErrorsComponent, FormFieldsModule, FormFileComponent, FormFileValidatorDirective, FormInputAutocompleteDirective, FormInputAutocompleteListComponent, FormInputComponent, FormMultiCheckboxComponent, FormMultiSelectComponent, FormNumberValidatorDirective, FormRadioComponent, FormSelectComponent, FormSelectOptionComponent, FormTextareaComponent, FormValidationMessageDirective, FullHeaderComponent, FullHeaderModule, IconComponent, IconModule, JsonConverterDirective, LanguageSelectorComponent, LanguageSelectorModule, LoadingDirective, LoadingEntity, LoadingLinkDirective, LoadingModule, LoadingSpinnerComponent, LoadingSpinnerModule, LoadingStatusComponent, LogoHeaderDirective, MainNavItemsDirective, MetaNavItemsDirective, ModalComponent, ModalDirective, ModalModule, ModalService, MultiSelectOptionDirective, MultiSelectTitleDirective, NavigationComponent, NavigationModule, NumberConverterDirective, PopoverComponent, PopoverDirective, PopoverModule, ProgressIndicatorComponent, ProgressIndicatorModule, RbUiComponentsModule, RelativeTimeInputComponent, SearchResultItemComponent, SearchResultModule, SubBrandHeaderDirective, SubNavItemsDirective, TAB_PANEL_RESOLVER, TIME_INPUT_OPTIONS, TabPanelComponent, TabPanelItemDirective, TabPanelModule, TabPanelRouterOutletDirective, TabPanelTitleDirective, TeaserPanelComponent, TeaserPanelItemComponent, TeaserPanelModule, TooltipDirective, customSelectSelectorFactory, defaultTimeInputOptions, emptyFunction$1 as emptyFunction, getRelativeInfo, isAbsolute, isRelative };
//# sourceMappingURL=inst-iot-bosch-angular-ui-components.js.map
